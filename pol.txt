UNIWERSYTET GDA.SKI
.agodne wprowadzenie do programowania w j¦zyku C
Jakub Neumann
GDA.SK 2010
0
Spis tre±ci
1 Naprawd¦ nie za dªugi wst¦p 3
1.1 Dla kogo ten skrypt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.2 Uwagi o j¦zyku C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2 Szybki start 6
2.1 .rodowisko pracy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.2 Pierwszy program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.3 Preprocesor i dyrektywy . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.4 Wy±wietlamy i wczytujemy dane . . . . . . . . . . . . . . . . . . . . . . . . 9
3 Zmienne i typy danych 13
3.1 Zmienne globalne i lokalne . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2 Liczbowe typy danych . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.3 Znaki i ªa«cuchy znakowe . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4 Operatory, arytmetyka, konwersje 20
4.1 Operatory arytmetyczne . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.2 Operatory relacyjne, prawda i faªsz . . . . . . . . . . . . . . . . . . . . . . 22
4.3 Operatory logiczne . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
4.4 Operatory przypisania . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.5 Priorytety . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.6 .¡czno±¢ i pozostaªe zasady . . . . . . . . . . . . . . . . . . . . . . . . . . 27
5 Instrukcje steruj¡ce 28
5.1 Instrukcje warunkowe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
5.2 P¦tle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
6 Tablice i struktury 35
6.1 Tablice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
6.2 Struktury . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
SPIS TRE.CI
7 Funkcje 42
7.1 Intuicje . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
7.2 Prototyp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
7.3 Tablice jako argumenty funkcji, problem rozmiaru tablicy . . . . . . . . . 44
7.4 Tablice dwuwymiarowe jako argumenty funkcji . . . . . . . . . . . . . . . . 45
7.5 Struktury jako argumenty funkcji . . . . . . . . . . . . . . . . . . . . . . . 47
7.6 Deniowanie funkcji . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
7.7 Zmienne statyczne w funkcji . . . . . . . . . . . . . . . . . . . . . . . . . . 49
7.8 Przekazywanie agumentów do funkcji przez warto±¢ i przez adres . . . . . . 50
8 Wska¹niki czyli nie taki diabeª straszny 52
8.1 Wska¹niki a tablice, arytmetyka wska¹nikowa, operator sizeof . . . . . . . . 54
8.2 Zarz¡dzanie pami¦ci¡ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
8.3 Wska¹niki, tablice a argumenty funkcji . . . . . . . . . . . . . . . . . . . . 58
8.4 Dynamiczne zarz¡dzanie pami¦ci¡ . . . . . . . . . . . . . . . . . . . . . . . 60
8.5 const oraz wska¹niki . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
9 Budowanie aplikacji 63
9.1 Pliki z funkcjami . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
9.2 Pliki nagªówkowe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
9.3 Wspóªdzielenie zmiennych, sªowa kluczowe extern i static . . . . . . . . . . 67
10 Naprawd¦ krótkie zako«czenie 69
2
Rozdziaª 1
Naprawd¦ nie za dªugi wst¦p
Szanowny czytelniku. Oddaj¦ w Twoje r¦ce ten skrypt i licz¦, »e pomo»e on Tobie rozpocz
¡¢, moim zdaniem wspaniaª¡, przygod¦ z programowaniem w j¦zyku C. My±l¦, »e
ka»dy informatyk, w szczególno±ci za± osoba posiadaj¡ca tytuª zawodowy informatyka,
powinna umie¢ programowa¢ w tym j¦zyku w stopniu przynajmniej podstawowym. Z
do±wiadczenia wiem te», »e programowanie mo»e dostarczy¢ wiele, wiele satysfakcji. Jednocze
±nie pami¦tam dobrze jak trudne byªy moje pocz¡tki programowania - wertowanie
ksi¡»ek, nierzadko do±¢ poka¹nych rozmiarów, pisanych trudnym, technicznym j¦zykiem.
St¡d pomysª stworzenia skryptu bazowego - pozwalaj¡cego drobnymi porcjami, krok po
kroku poznawa¢ podstawowe tajniki j¦zyka programowania C. Szczególnie u pocz¡tkuj¡-
cego programisty bardzo wa»n¡ rzecz¡ jest wyrobienie swego rodzaju intuicji i sprawno±ci
tworzenia podstawowego kodu. Chciaªby mocno podkre±li¢, »e skrypt ten nie stanowi
kompletnego opisu j¦zyka C, zawiera jednak materiaª z wi¦kszo±ci jego najistotniejszych
aspektów. Materiaªów do nauki j¦zyka C jest wiele i czytelnik bez trudu je odnajdzie w
bibliotece lub internecie. Najbardziej klasyczn¡ i kompletn¡ pozycj¡ jest J¦zyk ANSI C
autorstwa Briana Kernighan i Dennisa Ritchie. Wªa±nie do tej pozycji odsyªam czytelnika
gdy b¦dzie chciaª swoj¡ wiedz¦ pogª¦bi¢ lub rozwia¢ w¡tpliwo±ci. Celem tego skryptu jest
natomiast nauczenie czytelnika podstaw programowania w j¦zyku C przy u»yciu mo»liwie
niedu»ej ilo±ci teorii, przekazanej przy u»yciu j¦zyka potocznego, takiego jakim na
co dzie« posªuguj¡ si¦ programi±ci oraz sporej ilo±ci przykªadów. Podkre±lam, »e b¦d¦
celowo u»ywaª j¦zyka potocznego, rezygnuj¡c czasami z precyzji i jednoznaczno±ci jak¡
daje u»ycie j¦zyka bardziej formalnego.
Moje kilkuletnie do±wiadczenie w nauczaniu programowania dla pocz¡tkuj¡cych pokazuje,
»e maj¡ oni cz¦sto trudno±ci ze zrozumieniem prostych sformuªowa« typu: napisz
funkcj¦, która przyjmie parametry . . . i zwróci . . . albo przeka» do funkcji tablic¦
. . . i znajd¹ w niej . . . . Nierzadko popeªniaj¡ te» bardzo proste do unikni¦cia bª¦dy, na
przykªad te zwi¡zane z obsªug¡ ªa«cuchów znakowych. J¦zyk C jest j¦zykiem, który do
rozpocz¦cia w miar¦ sprawnego programowania wymaga poznania pewnej liczby podstawowych
poj¦¢. Wielokrotnie obserwowaªem u swoich sªuchaczy zakªopotanie wywoªane
1. NAPRAWD. NIE ZA D.UGI WST.P
brakiem znajomo±ci rzeczy le»¡cych u podstaw, które zniech¦caªo lub wr¦cz blokowaªo
dalsz¡ nauk¦. Wªa±nie w celu przeprowadzenia czytelnika, krok po kroku, przez te, by¢
mo»e trudne dla niego pocz¡tki, powstaª ten skrypt. Zdaj¦ sobie spraw¦, »e aby czytelnik
natychmiast nie porzuciª natychmiast tego skryptu, ilo±¢ stron nie mo»e by¢ zbyt du»a.
Obiecuj¦ zmie±ci¢ si¦ w okoªo siedemdziesi¦ciu.
1.1 Dla kogo ten skrypt
Skrypt ten przeznaczony jest gªownie dla osób, które dopiero zaczynaj¡ nauk¦ programowania
i »adnej wiedzy zwi¡zanej z programowaniem w j¦zyku C nie posiadaj¡. Przyjmowaª
b¦d¦ jednak, »e czytelnik zna te najbardziej bazowe poj¦cia zwi¡zane z programowaniem,
takie jak na przykªad czym jest algorytm lub do czego sªu»¡ zmienne oraz zna stoj¡ce za
tymi poj¦ciami intuicje. Ja ze swej strony, w miar¦ mo»liwo±ci, b¦d¦ staraª si¦, w kilku
sªowach, poj¦cia te równie» przybli»a¢.
Jak czyta¢ ten skrypt? Stworzyªem go z my±l¡ o czytelniku, który b¦dzie studiowaª
go w kolejno±ci w jakiej wyst¦puj¡ rozdziaªy a kolejne poj¦cia pojawia¢ si¦ b¦d¡ na bazie
wcze±niej wprowadzonych. W kilku zaledwie miejscach wprowadzam takie, które zostan¡
wyja±nione dokªadniej w pó¹niejszych rozdziaªach ale s¡ one na tyle proste, »e czytelnik
nie b¦dzie miaª »adnego problemu z ich zrozumieniem.
1.2 Uwagi o j¦zyku C
Wspóªcze±nie j¦zyk C mo»e by¢ uznany za j¦zyk niskiego poziomu. Mamy w nim na
przykªad mro»¡ce krew w »yªach wska¹niki, których wi¦kszo±¢ nowoczesnych j¦zyków nie
dopuszcza w takiej postaci jak w j¦zyku C. Jednak gor¡co zapewniam czytelnika, »e trud
nauki tego j¦zyka nie pójdzie na marne. Skªadnia, któr¡ tu pozna jest w pewnym sensie
uniwersalna i cz¦±ciowo wykorzystywana w znakomitej liczbie innych, nowszych j¦zyków
(C++, Java, C#, ActionScript). A intuicja zwi¡zana z programowaniem niskopoziomowym,
któr¡ mam nadziej¦ posi¡dzie, b¦dzie rzecz¡ bezcenn¡.
Od strony formalnej chciaªbym zaznaczy¢, j¦zyk C jest j¦zykiem standardowym, to
znaczy »e jego reguªy opisane s¡ ocjalnymi dokumentami organizacji takich jak ANSI
oraz ISO. Bez wdawania si¦ w szczegóªy mo»emy przyj¡¢ »e istniej¡ dwa dialekty j¦zyka
C. Jeden to starszy standard C90 (ISO/IEC 9899:1990) a drugi, nowszy, to C99 (ISO/IEC
9899:1999). Wi¦kszo±¢ wspóªczesnych kompilatorów j¦zyka C w peªni wspiera pierwszy z
wymienionych standardów, natomiast drugi w wi¦kszej i zasadniczej jego cz¦±ci. Dotyczy
to równie» u»ywanego przez nas kompilatora gcc. Jakie znaczenie ma to dla czytelnika?
Otó» tryb zgodno±ci domy±lnie przyj¦ty przez kompilator gcc to C90. Nie dopuszcza
on wszystkich konstrukcji, które czytelnik mo»e napotka¢ w przykªadach znajdowanych
w sieci lub w ksi¡»kach. Przykªadowo, je±li b¦dzie u»ywaª, wedªug mnie bardzo zreszt¡
4
1. NAPRAWD. NIE ZA D.UGI WST.P
przydatnych, komentarzy jednolinijkowych // mo»e otrzyma¢ ostrze»enia od kompilatora
o niezgodno±ci standardów. Na tym etapie nauki mo»e je jednak zignorowa¢ lub u»ywa¢
odpowiedniego przeª¡cznika programu gcc. Ja jednak b¦d¦ we wszystkich podawanych
przykªadach zgodny ze starym, bazowym standardem C90.
5
Rozdziaª 2
Szybki start
Spraw¡ bardzo istotn¡ jest aby czytelnik zacz¡ª pisa¢ kod jak najszybciej. Najlepsz¡
form¡ nauki programowania jest cz¦ste jego praktykowanie, dlatego ju» w tym miejscu
gor¡co zach¦cam czytelnika do eksperymentowania z kodem.
2.1 .rodowisko pracy
Do rozpocz¦cia pracy potrzebujemy jedynie kompilatora zgodnego z ANSI C oraz edytora
tekstowego.
Kompilator wraz z towarzysz¡cymi mu narz¦dziami sªu»y¢ b¦dzie do tªumaczenie kodu
¹ródªowego (czyli pisanych przez nas programów) na format obsªugiwany przez system
operacyjny. Najprostszym sposobem pozyskania gotowego ±rodowiska pracy jest dost¦p
lub samodzielna instalacja systemu Linux. Poniewa» j¦zyk C jest natywnym j¦zykiem tego
systemu operacyjnego, kompilator j¦zyka C (najcz¦±ciej o nazwie gcc) z reguªy dost¦pny
jest natychmiast, bez potrzeby dodatkowej instalacji. Je±li czytelnik posiada system operacyjny
Windows i nie chciaªby instalowa¢ systemu Linux na osobnej partycji czy dysku
komputera, mo»e albo zainstalowa¢ go w formie maszyny wirtualnej (szukaj w internecie
pod hasªami: Windows Virtual PC, VirtualBox, VmWare Player) albo skorzysta¢ z dystrybucji
Live CD, która uruchamia system Linux bezpo±rednio ze stacji DVD/CD, nie
ingeruj¡¢ w »aden sposób w instalacje bie»¡cego systemu operacyjnego. Ze swej strony
mog¦ poleci¢ dystrybucj¦ i instalacj¦ systemu Ubuntu Live CD. Czytelnik znajdzie bez
trudu opis instalacji czy uruchamiania tej dystrybucji w internecie. Pozyskanie kompilatora
ANSI C bezpo±rednio dla systemu Windows jest trudniejsze i nie b¦dzie tutaj szerzej
omawiane. Jako przykªad mog¦ wskaza¢ rozwi¡zanie w postaci ±rodowiska cygwin oraz
mingw. Szczegóªowe informacje dost¦pne s¡ w internecie. W dalszej cz¦±ci b¦d¦ zakªadaª,
»e pracujemy w ±rodowisku Linux oraz dost¦pny jest polecany przeze mnie kompilator o
nazwie gcc.
Do pisania kodu ¹ródªowego musimy posiada¢ jeszcze zwykªy edytor plików w formacie
tekstowym. Istniej wiele ±wietnych edytorów tekstowych czy wr¦cz caªych ±rodowisk
2. SZYBKI START
programistycznych znakomicie przyspieszaj¡cych i uªatwiaj¡cych tworzenie kodu. Jednak
na wczesnym etapie nauki programowania gor¡co radz¦ czytelnikowi, »eby skorzystaª
z mo»liwie prostego edytora - programista najlepiej uczy si¦ na wªasnych bª¦dach, co
szczególnie dotyczy bª¦dów skªadniowych. Ponadto poprawianie bª¦dów jest równie» sposobem
poznawania j¦zyka, a po pewnym, nie za dªugim (obiecuj¦!) czasie czytelnik b¦dzie
popeªniaª niewiele bª¦dów zwi¡zanych ze skªadni¡. Na pocz¡tek jednak wystarczy, je±li
edytor b¦dzie jedynie kolorowaª skªadni¦ programu (oprócz oczywi±cie zwykªych czynno-
±ci zwi¡zanych z obsªug¡ tekstu). Mog¦ poleci¢ ze ±wiata systemu Linux edytory gedit
dla ±rodowiska gracznego, vim, emacs, mcedit dla ±rodowiska terminala textowego, a ze
±wiata systemu Windows program notepad++.
2.2 Pierwszy program
Zgodnie z pradawnym zwyczajem programistów, pierwszy program w j¦zyku, który poznajemy,
powinien wy±wietli¢ napis Hello World :
1 #include <s t d i o . h>
3 int main ( ) {
p r i n t f ( "He l l o World\n" ) ;
5 return 0 ;
}
Po zapisaniu kodu programu w pliku hello.c przyst¦pujemy do etapu przetªumaczenia
kodu ¹ródªowego na posta¢ programu, który mo»emy uruchomi¢. W okienku terminala
uruchamiamy kompilator podaj¡c jako argument nasz program ¹ródªowy:
gcc hello.c
W wyniku poprawnej kompilacji powstaje plik wykonywalny o nazwie a.out. Mo»emy
go uruchomi¢:
./a.out
Chciaªbym w tym miejscu zaznaczy¢, »e przy tworzeniu pliku wykonywalnego, tak naprawd
¦ wyst¦puj¡ dwa etapy. Jeden z nich to kompilacja a drugi konsolidacja (inaczej: linkowanie).
Zagadnieniu budowania kodu przyjrzymy si¦ dokªadniej w osobnym rozdziale.
Na razie jednak przyjmijmy po prostu, »e kompilacja i linkowanie odbywaj¡ si¦ ª¡cznie
i wykonujemy je jednym poleceniem gcc. Program gcc ma bardzo du»o przeª¡czników.
Na pocz¡tkowym etapie nauki przydatnych jest zaledwie kilka. Jeden z przeª¡czników
zmienia nazw¦ pliku wykonywalnego z domy±lnej a.out na podany przez u»ytkownika.
Jest to przeª¡cznik -o (zapami¦tajmy: -o jak output):
gcc hello.c -o sayhello
./sayhello
Kolejne przeª¡czniki b¦d¡ pojawia¢ si¦ w miar¦ potrzeb, w dalszej cz¦±ci skryptu.
7
2. SZYBKI START
Wyja±nijmy teraz pokrótce (szczegóªy b¦d¡ odkrywane w dalszej cz¦±ci skryptu) z
czego skªada si¦ i jak dziaªa nasz program. Otó» punktem od którego rozpoczyna si¦ wykonywanie
programu w j¦zyku C jest funkcja o nazwie main(). W jej ciele (ciaªo stanowi
kod pomi¦dzy nawiasami klamrowymi { }) umieszczamy kolejne instrukcje programu.
Tutaj mamy tylko dwie instrukcje. Pierwsz¡ z nich jest wywoªanie funkcji printf(),
która wy±wietla na wyj±ciu (tutaj: ekranie komputera) swój argument - ªa«cuch znaków
Hello World. .a«cuchy znakowe w C tworzymy umieszczaj¡c napis pomi¦dzy znakami
" ". Instrukcja return ko«czy dziaªanie funkcji i zwraca warto±¢ 0. W wypadku funkcji
main warto±¢ ta przekazywana jest do ±rodowiska - systemu operacyjnego. Zwrócone 0 z
programu oznacza, zgodnie z konwencj¡, prawidªowe jego zako«czenie. Kolejny podrozdzia
ª omawia zagadnienia zwi¡zane z pierwsz¡ lini¡ naszego programu.
2.3 Preprocesor i dyrektywy
Pierwsza linijka kodu, rozpoczynaj¡ca si¦ znakiem # zawiera dyrektyw¦ preprocesora o nazwie
include. O preprocesorze mo»emy my±le¢ jak o prostym programie, uruchamianym
przed wªa±ciw¡ kompilacj¡, którego zadaniem jest wykonywanie prostych czynno±ci tekstowych
takich jak doª¡czanie do kodu ¹ródªowego zawarto±ci innych plików tekstowych
(dyrektywa include) czy te» podmiana napisów (dyrektywa define). W omawianym
przypadku dyrektywa include doª¡czy zawarto±¢ pliku stdio.h, który zawiera deklaracje
funkcji printf, z której korzystamy w programie. Dlaczego powinni±my przedstawia¢
(deklarowa¢) kompilatorowi u»ywane funkcje wyja±nione zostanie dokªadnie w rozdziale
po±wi¦conym funkcjom. Plik stdio.h zawiera m.in. deklaracje funkcji zwi¡zanych z
obsªug¡ wej±cia (na przykªad klawiatura) i wyj±cia (na przykªad ekran lub plik). Zapami
¦tajmy: stdio jak skrót od standard input output. Pliki z deklaracjami nazywamy nag
ªówkowymi i nadajemy im zwykle rozszerzenie *.h (h od sªowa header). Zapami¦tajmy,
»e dyrektywa include i dziaªanie preprocesora powoduj¡ jedynie wstawienie zawarto±¢
pliku tekstowego do procesu kompilacji. Nie powoduje to wª¡czenia do kompilacji »adnej
biblioteki (tj. pliku binarnego ze skompilowanym kodem funkcji)! Bardzo cz¦stym bª¦-
dem popeªnianym przez pocz¡tkuj¡cych programistów j¦zyka C jest przekonanie, »e samo
u»ycie include doª¡czy skompilowane denicje potrzebnych funkcji. Efektem dziaªania
include, w tym wypadku, jest jedynie przedstawienie kompilatorowi funkcji. Uwa»ny
czytelnik zapyta zapewne gdzie znajduje si¦ denicja funkcji printf() skoro nie doª¡-
cza jej »adna dyrektywa. Otó» implementacje, czyli skompilowane denicje funkcji, które
bardzo cz¦sto wchodz¡ w skªad wielu programów, s¡ cz¦±ci¡ biblioteki standardowej C i
s¡ automatycznie doª¡czane do ka»dej kompilacji. W bibliotece tej znajduj¡ si¦ m.in implementacje
funkcji systemu wej±cia wyj±cia oraz wszystkie funkcje wywoªywane w tym
skrypcie (oprócz oczywi±cie tych, które sami napiszemy).
8
2. SZYBKI START
Zapami¦taj! Dyrektywa include nie powoduje wª¡czenia bibliotek w proces budowania
kodu. Doª¡cza jedynie zawarto±¢ tekstowych plików nagªówkowych, w których
znajduj¡ si¦ deklaracje (a nie denicje) funkcji.
Drug¡ cz¦sto wykorzystywan¡ dyrektyw¡ jest define. Jako przykªad rozwa»my dyrektyw
¦ #define PI 3.14. W wyniku jej dziaªania, w kodzie programu wyst¡pienia napisu
PI zostan¡ zast¡pione napisem 3.14. Zamiana nie b¦dzie dotyczy¢ jednak napisów zde-
niowanych przez samego programist¦ (tj. ªa«cuchów znaków uj¦tych w cudzysªów " ").
Sprawd¹my co wydrukuje nast¦puj¡cy program:
#include <s t d i o . h>
2 #define PI 3 . 14
4 int main ( ) {
p r i n t f ( "PI do kwadratu wynosi : %f \n" , PI PI ) ;
6 return 0 ;
}
W efekcie dziaªania preprocesora, do funkcji printf(), jako drugi argument przekazany
zostanie napis 3.14*3.14, który w momencie jej wywoªania wyliczony zostanie do
odpowiedniej warto±¢ liczbowej, reprezentuj¡cej kwadrat liczby 3:14. Dyrektywy #define
nie nale»y jednak nadu»ywa¢, w szczególno±ci, w powy»szym przykªadzie powinni±my pos
ªu»y¢ si¦ raczej zmienn¡. O tym, w jaki sposób wy±wietla¢ warto±ci liczbowe i warto±ci
zmiennych traktuje nast¦pny podrozdziaª.
2.4 Wy±wietlamy i wczytujemy dane
Na wczesnym etapie nauki j¦zyka programowania wa»ne jest aby mo»liwie du»o eksperymentowa
¢ z kodem i dlatego powiemy w tym miejscu, jak korzysta¢ w peªni z funkcji
printf(), czyli wy±wietla¢ dane na ekranie oraz funkcji scanf(), czyli pobiera¢ dane z
klawiatury.
Najpierw jednak powiemy w jaki sposób przechowywa¢ w j¦zyku C dane liczbowe i
napisy. Jak czytelnik zapewne doskonale wie, pojemniki, które przechowuj¡ takie warto±ci
s¡ zwane zmiennymi. J¦zyk C nale»y do tych j¦zyków, które wymagaj¡ od programisty
podania (zadeklarowania) dla ka»dej zmiennej jej typu. Typom danych po±wi¦cony jest
kolejny rozdziaª, tutaj tylko poka»emy prawidªowe deklaracje zmiennych kilku podstawowych
typów tak, aby mo»na byªo zaprezentowa¢ dziaªanie funkcji printf() oraz scanf().
Aby powoªa¢ do »ycia zmienn¡ nale»y j¡ zadeklarowa¢, to znaczy poda¢ jej typ danych
oraz nazw¦. Je±li chodzi o nazwy zmiennych to zapami¦tajmy tylko, »e mog¡ rozpoczyna¢
si¦ jedynie od litery lub znaku podkre±lenia _ i dalej zawiera¢ litery, cyfry oraz znak podkre
±lenia. Nazwy (zmiennych, funkcji) nie mog¡ rzecz jasna zawiera¢ spacji. Nie nale»y
9
2. SZYBKI START
te» u»ywa¢ w nich polskich liter diakrytyzowanych (czyli ¡, ¦, ¢, ¹ itp.). Wielko±¢ liter
jest w C znacz¡ca czyli Pi i pi to dwie ró»ne nazwy.
1 #include <s t d i o . h>
3 int main ( ) {
int r = 2 ;
5 double pi = 3 . 1 4 1 5 9 ;
f loat e ;
7 p r i n t f ( "Pole kola o promieniu %d wynosi ok . %f \n" , r , pi  r  r ) ;
e = 2 . 7 1 8 2 8 1 8 ;
9 p r i n t f ( " Liczba Eulera wynosi ok . %f \n" , e ) ;
return 0 ;
11 }
W funkcji main() pojawiªy si¦ deklaracje trzech zmiennych liczbowych. int jest typem
danych reprezentuj¡cych liczy caªkowite. Typy double oraz float reprezentuj¡ z kolei
liczby zmiennopozycyjne. We wspóªczesnych programach w j¦zyku C do oblicze« zmiennopozycyjnych
powinni±my w zasadzie u»ywa¢ wyª¡cznie liczb podwójnej precyzji czyli
typu double, gdy» wi¦kszo±¢ funkcji matematycznych wymaga argumentów typu double
a nie float. Ponadto procesory s¡ optymalizowane pod k¡tem pracy z takimi liczbami.
Przyjrzymy si¦ teraz dokªadniej funkcji printf(). Pierwszy argument tej funkcji,
zwany formatem (st¡d printf czyli print z formatem), to napis, który pojawi si¦ na wyj-
±ciu wraz z miejscami, w które maj¡ zosta¢ wstawione warto±ci zmiennych lub wyra»e«.
Miejsca te oznaczamy za pomoc¡ znaku % oraz kodów odpowiadaj¡cym typom zmiennych
lub wyra»e«, które zamierzamy wy±wietli¢. Same zmienne lub wyra»enia s¡ kolejnymi
argumentami funkcji i ich warto±ci wstawiane s¡ w te miejsca w kolejno±ci w jakiej wyst
¦puj¡. Kilka najcz¦±ciej wykorzystywanych kodów:
 %d oraz %i- liczba caªkowita ze znakiem w systemie dziesi¦tnym
 %f - liczba double w postaci [-]ddd.ddd
 %e - liczba double w postaci notacji wykªadniczej
 %c - znak
 %s - ªa«cuch znaków
Je±li chcemy dodatkowo poda¢ ile miejsc po przecinku ma zosta¢ wy±wietlonych, do kodów
dodajemy t¦ informacj¦ po kropce, po znaku %. Na przykªad %.3f pozwala wy±wietli¢
liczb¦ typu double z trzema miejscami po przecinku.
10
2. SZYBKI START
W skªad ªa«cucha formatuj¡cego mog¡ wchodzi¢ równie» kody znaków specjalnych
takich jak znak przej±cia do nowej linii \n czy tabulator poziomy \t. Te dwa znaki
specjalne s¡ najcz¦±ciej wykorzystywane, pozostaªe za± raczej rzadko.
Zajmijmy si¦ teraz przekazywaniem do programu danych z klawiatury.
1 #include <s t d i o . h>
3 int main ( ) {
int dd , mm, r r ;
5 char po twi e rdz eni e [ 4 ] ;
p r i n t f ( "Podaj date w formac i e dd..mm..r r : " ) ;
7 s c anf ( " %d..%d..%d" , &dd , &mm, &r r ) ;
p r i n t f ( "Data %d..%d..%d poprawna [ tak / ni e ] ? " , dd , mm, r r ) ;
9 s c anf ( " %s " , po twi e rdz eni e ) ;
p r i n t f ( "Data potwierdzona : %s \n" , po twi e rdz eni e ) ;
11 return 0 ;
}
Funkcja scanf() podobnie jak printf() jako pierwszy argument pobiera ªa«cuch formatuj
¡cy. Jednak tym razem format informuje jakie znaki powinny znale¹¢ si¦ we wczytywanym
ªa«cuchu oraz w których jego miejscach wyst¦puj¡ warto±ci, które chcemy pobra
¢. W naszym przypadku ªa«cuch formatuj¡cy to " %d-%d-%d" i funkcja spodziewa si¦
trzech liczb caªkowitych rodzielonych znakiem -. Dalej, zwró¢my uwag¦ w jaki sposób
przekazywane s¡ argumenty b¦d¡ce miejscem czyli zmiennymi do których zapisujemy
wczytywane dane. Poprzedza je znak & i oznacza, »e przekazujemy do funkcji nie warto±¢,
któr¡ zmienn¡ reprezentuje ale jej adres, tak aby funkcja wiedziaªa gdzie te dane zapisa¢.
Jest to tak zwane przekazywanie parametrów przez adres. Kwestie te b¦d¡ szczegóªowo
omówione w rozdziale po±wi¦conym funkcjom. Na razie zapami¦tajmy: aby funkcja scanf
mogªa wypeªni¢ zmienne danymi, przekazujemy jej adres zmiennych w postaci &zmienna.
Zauwa»my te», »e przy przekazywaniu tablicy potwierdzenie, w tym wypadku znakowej
(w j¦zyku C nie ma osobnego typu danych okre±laj¡cego napisy znakowe), & nie wyst
¦puje. Dzieje si¦ tak dlatego, »e zmienna tablicowa reprezentuje tak naprawd¦ adres
swojego pierwszego elementu (dokªadniej wyja±nimy to w rozdziale o tablicach). Pami¦-
tajmy równie», »e je±li wczytujemy ªa«cuch znakowy z klawiatury, to nie mo»e on zawiera¢
spacji - spacja rozdzieli kolejne ªa«cuchy na wej±ciu. Do wczytania napisu, który mo»e
zawiera¢ spacje potrzebne s¡ inne rozwi¡zania, na przykªad wczytanie caªej linii. Jednak
dla prostoty przyjmijmy od tego miejsca, »e we wszystkich przykªadach, gdy b¦dziemy
wczytywali napis b¦dziemy mieli na my±li ªa«cuch znakowy bez spacji.
Analizuj¡c dalej nasz prosty program zauwa»my, »e zmienne r oraz pi zostaªy zainicjalizowane
w miejscu deklaracji. Zmiennej e warto±¢ zostaªa nadana dopiero w dalszej
instrukcji programu. Zapami¦tajmy: zmienne powinny by¢ inicjalizowane jak najszyb-
11
2. SZYBKI START
ciej, najlepiej w momencie deklaracji. Zmienne deklarowane, a nie zainicjalizowane w
funkcjach (s¡ to zmienne lokalne) maj¡ nadane przypadkowe warto±ci.
.wiczenie 2.1 Sprawdzi¢ jakie warto±ci nadane zostan¡ zmiennym lokalnym funkcji main(),
które nie zostaªy zainicjalizowane. Uruchomi¢ program kilkakrotnie.
12
Rozdziaª 3
Zmienne i typy danych
W rozdziale tym przyjrzymy si¦ dokªadniej zmiennym, wyró»nimy zmienne globalne i
lokalne oraz powiemy par¦ sªów wi¦cej o podstawowych typach danych.
3.1 Zmienne globalne i lokalne
Ka»da zmienna istnieje w programie przez okre±lony czas. Czas jej »ycia zale»y od tego
gdzie zostaªa zdeniowana tj. utworzona. Je»eli zmienn¡ utworzymy poza wszelkimi
funkcjami, w tym równie» poza funkcj¡ main(), taka zmienna staje si¦ w peªni dost¦pna
(inaczej: widoczna) dla pozostaªego kodu programu, w tym równie» ciaª wszystkich jego
funkcji, a nawet innych plików ¹ródªowych programu! Dlatego wªa±nie takie zmienne
nazywamy globalnymi. Natomiast zmienne, które tworzymy (deklarujemy) wewn¡trz jakiej
± funkcji , w tym równie» funkcji main(), s¡ zmiennymi, które »yj¡ tylko w czasie
wykonywania tej funkcji i zwane s¡ zmiennymi lokalnymi . Gdy funkcja jest wywoªywana,
zmienne takie s¡ tworzone a po zako«czeniu jej dziaªania niszczone. Dzieje si¦ tak za ka»-
dym razem gdy funkcja jest w programie wywoªywana. .wiczenie z ko«ca poprzedniego
rozdziaªu pokazaªo naocznie, »e zmienne lokalne nie s¡ domy±lnie inicjalizowane w »aden
sposób, to znaczy ich warto±¢ jest niezdeniowana. Zmienne globalne natomiast, inicjalizowane
s¡ warto±ciami zerowymi dla danego typu. Sprawd¹my, uruchamiaj¡c kilkakrotnie
poni»szy program:
#include <s t d i o . h>
2
int g l oba lna ;
4 int main ( ) {
int l o k a lna ;
6 p r i n t f ( "Globalna %d , l o k a lna %d\n" , globalna , l o k a lna ) ;
return 0 ;
8 }
3. ZMIENNE I TYPY DANYCH
Zobaczmy teraz co si¦ stanie, gdy utworzymy zmienn¡ globaln¡ i lokaln¡ o tej samej
nazwie. Jak¡ warto±¢ wydrukuje poni»szy program?
#include <s t d i o . h>
2
/ Globalna /
4 int zmienna = 1 ;
6 int main ( ) {
/ Lokalna f u n k c j i main ( ) /
8 int zmienna = 2 ;
10 p r i n t f ( "Zmienna %d\n" , zmienna ) ;
return 0 ;
12 }
W powy»szym przykªadzie w kodzie pojawiªy si¦ komentarze. Napisy umieszczane pomi
¦dzy par¡ znaków /* i */ s¡ caªkowicie ignorowane przez kompilator. Komentarze
dotycz¡ bie»¡cej sytuacji w kodzie i zawieraj¡ informacje skierowane do niego samego
lub innej osoby, która b¦dzie jego kod rozwija¢. Cz¦sto zawieraj¡ wskazówki o u»ytych
konstrukcjach my±lowych. My b¦dziemy u»ywali komentarzy do wskazywania rozmaitych
omawianych wªa±nie aspektów.
Wró¢my do przykªadu. Analizowany kod ilustruje przykrywanie zmiennych o tych
samych nazwach ale zdeniowanych w ró»nych zakresach. Jest to sytuacja potencjalnie
niebezpieczna, gdy» w przypadku skomplikowanej funkcji czy struktury programu,
programista mógª chcie¢ skorzysta¢ ze zmiennej globalnej ale nie zauwa»yª, »e wcze±niej
zostaªa ona przykryta przez zmienn¡ zdeniowan¡ lokalnie. Dlatego te» nowoczesne j¦-
zyki programowania zabraniaj¡ przykrywania zmiennych i sygnalizuj¡ bª¡d ju» na etapie
kompilacji. Kompilator j¦zyka C, niestety, nie wysyªa nawet ostrze»e« o zaistnieniu takiej
sytuacji.
3.2 Liczbowe typy danych
Do tej pory poznali±my nast¦puj¡ce typy danych: int, double, float. Istniej¡ jeszcze
typy caªkowite short int (pisany zazwyczaj skrótowo short) oraz long int (pisany
zazwyczaj skrótowo long). Typy te maj¡ reprezentowa¢ liczby caªkowite z mniejszym
(odpowiednio: wi¦kszym) zakresem, przy u»yciu by¢ mo»e mniejszej (odpowiednio: wi¦kszej)
ilo±ci bitów. Zakresy liczb, które mo»emy zapisa¢ przy u»yciu tych liczb mog¡ (ale
nie musz¡!) by¢ inne ni» dla typu int. Najwi¦ksze i najmniejsze liczby, które da si¦
zapisa¢ w danym typie caªkowitym s¡ zale»ne od architektury sprz¦towej i systemowej na
której dziaªa kompilator C.
14
3. ZMIENNE I TYPY DANYCH
Standard j¦zyka C okre±la jednak wspólne miejsce, w którym jest przechowywana informacja
o zakresach na konkretn¡ maszyn¦. Tym miejscem jest systemowy plik nagªówkowy
<limits.h>. Spróbujmy wi¦c odczyta¢ staªe przechowuj¡ce warto±ci najwi¦ksze i
najmniejsze dla poszczególnych typów.
#include <s t d i o . h>
2 #include <l imi t s . h>
4 int main ( ) {
p r i n t f ( " sho r t : min %d , max %d\n" , SHRT_MIN, SHRT_MAX) ;
6 p r i n t f ( " i n t : min %d , max %d\n" , INT_MIN, INT_MAX) ;
p r i n t f ( " long : min %ld , max %ld \n" , LONG_MIN, LONG_MAX) ;
8 return 0 ;
}
Na maszynie autora typy long oraz int maj¡ takie same zakresy! W rozwa»anym programie
zwró¢my uwag¦ na format pozwalaj¡cy odczyta¢ liczb¦ typu long : %ld. Format
ten powstaje przez dodanie modykatora l. Standard ANSI C deniuje jeszcze typy
long long, long double, przeznaczone raczej do specjalnych zastosowa«. Mo»emy je
wy±wietla¢ poprzez dodanie kolejnego modykatora l, na przykªad dla typu long long:
%lld. Jak wskazywa¢, »e dana liczba reprezentuje warto±¢ long a nie int? Podobnie
z double i long double? Czynimy to poprzez dodanie litery L lub l (l jak long)
bezpo±rednio za warto±ci¡, na przykªad long i = 23454L; long double x = 3.14l;.
Analogicznie liczb¦ typu float wska»emy przez dodanie litery F lub f.
.wiczenie 3.1 Na swojej maszynie znale¹¢ plik limits.h i znale¹¢ dyrektyw¦ define
deniuj¡c¡ zakresy dla liczb long long.
Czasami przydaje si¦ tak»e zapisa¢ i wy±wietla¢ liczby w systemie szesnastkowym. Aby
poda¢ warto±¢ w systemie szesnastkowym nale»y na jej pocz¡tku umie±ci¢ znaki 0x:
int kopa = 0x3C;
printf("Kopa w systemie szesnastkowym:%x\n ", kopa);
printf("Kopa w systemie dziesietnym:%d\n", kopa);
3.3 Znaki i ªa«cuchy znakowe
Wyja±nimy teraz w jaki sposób przechowywa¢ pojedyncze znaki i caªe napisy (ªa«cuchy
znaków). Do przechowywania pojedynczych znaków wykorzystywany jest typ char. Warto
±ci zmiennych tego typu mo»emy podawa¢ na kilka sposobów. Jednym z nich jest uj¦cie
znaku w apostrof, np. char latin_a = 'a'. Innym jest podanie kodu ASCII znaku,
na przykªad char latin_b = 98 lub w systemie szesnastkowym char latin_k = 0x6b.
Czytelnik zapewne zauwa»a w tym momencie, »e typ char tak naprawd¦ przechowuje dane
15
3. ZMIENNE I TYPY DANYCH
liczbowe - kody znaków. Rzeczywi±cie, zmienne typu char to liczby caªkowite zapisane
na jednym bajcie. Ogranicza to ilo±¢ ró»nych znaków do 256. Je±li chcemy wykorzystywa
¢ kodowanie wielobajtowe takie jak UTF-8 czy generalnie Unicode, musimy u»y¢ typu
wchar_t (ang. wide character), zdeniowanego w pliku nagªówkowym <wchar.h>. Deklaracje
wielu przydatnych funkcji operuj¡cych na ªa«cuchach takich znaków znajduj¡ si¦
natomiast w pliku <wctype.h>. Zwró¢my równie» uwag¦ na to, »e aby móc prawidªowo
obsªugiwa¢ polskie litery diakrytyzowane, terminal (linia polece«) na którym pracujemy
musi obsªugiwa¢ odpowiedni rodzaj kodowania. W nowoczesnych systemach jest to UTF-
8 (szukaj w internecie pod hasªem locale). Nasz edytor, w którym piszemy kod ¹ródªowy
równie» musi wspiera¢ kodowanie w tym formacie i odpowiednio reagowa¢ na znaki z ogonkami.
Powa»ne podej±cie do tematu polskich znaków w programach w j¦zyku C wychodzi
poza zakres niniejszego skryptu i równie» czytelnikowi radz¦ unika¢ go na pocz¡tkowym
etapie nauki.
Je±li chodzi o ªa«cuchy znaków to w j¦zyku C nie istnieje osobny typ do ich reprezentowania.
Zamiast tego ªa«cuchy przechowujemy jako tablice znaków. Cho¢ tablice b¦d¡
tematem osobnego rozdziaªu, to ju» w tym miejscu mo»emy poda¢ prawidªowy sposób
posªugiwania si¦ ªa«cuchami znakowymi. Czytelnik bez trudu zrozumie deklaracje tablic
znakowych:
16
3. ZMIENNE I TYPY DANYCH
1 #include <s t d i o . h>
#include <s t r i n g . h>
3
int main ( ) {
5 char t y t u l [ 7 0 ] = "magi s t e r " ;
char nazwisko [ 5 0 ] ;
7 char powi tani e [ 1 0 0 ] ;
9 / Wczytywanie i wy swi e t l ani e /
p r i n t f ( "Twoje nazwisko : " ) ;
11 s c anf ( "%s " , nazwisko ) ;
p r i n t f ( "Brzmi dobrze : %s%s ?\n" , tytul , nazwisko ) ;
13
/ Konkatenacja c z y l i l a c z e n i e lancuchow /
15 s t r c a t ( tytul , nazwisko ) ;
17 / Kopiowanie lancuchow /
s t r cpy ( powi tanie , "Witaj " ) ;
19 s t r c a t ( powi tanie , t y t u l ) ;
p r i n t f ( "%s ! \ n" , powi tani e ) ;
21 return 0 ;
}
Spróbujmy zebra¢ kilka najwa»niejszych aspektów dotycz¡cych ªa«cuchów znakowych:
 .a«cuchy znakowe mog¡ by¢ inicjalizowane bezpo±rednio w deklaracji napisem uj¦-
tym w znaki " "
 Deklaracje przydatnych funkcji przeznaczonych do obsªugi ªa«cuchów znakowych
znajduj¡ si¦ w pliku <string.h>. Nale»y go doª¡czy¢, gdy chcemy korzysta¢ z tych
funkcji
 Do kopiowania ªa«cuchów u»ywamy funkcji strcpy(). Zwró¢my uwag¦ na 18 lini
¦ kodu. Jest to poprawny sposób na wypeªnianie ªa«cucha. Bardzo cz¦stym
bª¦dem u pocz¡tkuj¡cych programistów C jest taki sposób wypeªniania ªa«cucha:
nazwisko = "Kowalski" ! Jedynym miejscem w kodzie gdzie mo»na u»y¢ operatora
przypisania = i napisu uj¦tego w " " jest moment deklaracji, tak jak to zostaªo
zrobione w przypadku zmiennej tytul w 5 linii kodu.
 Do ª¡czenia (inaczej konkatenowania) u»ywamy funkcji strcat()
 Do wyznaczania dªugo±ci ªa«cucha u»ywamy funkcji strlen()
17
3. ZMIENNE I TYPY DANYCH
 Do porównywania ªa«cuchów u»ywamy funkcji strcmp()
 Pami¦tajmy, »e ªa«cuch, na który kopiujemy lub do którego doª¡czamy musi by¢
odpowiednio dªugi aby operacja daªa spodziewany wynik. Nale»y pami¦ta¢ tak»e o
miejscu na znak ko«ca ªa«cucha (szczegóªy poni»ej).
Do dokªadniejszego wyja±nienia pozostaje kwestia dªugo±ci ªa«cucha i jego reprezentacji
w pami¦ci. Wiemy ju», »e ªa«cuch to tak naprawd¦ tablica znakowa. W j¦zyku C tablice
nie przechowuj¡ informacji o tym gdzie znajduje si¦ ich koniec albo ile elementów zawieraj
¡. Tablica to dla programu jedynie ci¡gªy obszar pami¦ci. Jak w takim razie funkcja
scanf() czy strcpy() wyznacza koniec tablicy do wy±wietlania czy kopiowania? Otó»
ka»dy napis wyst¦puj¡cy w kodzie i uj¦ty w " " ma niejawnie jako ostatni znak doª¡czony
null character, czyli znak '\0', który wyznacza jego koniec. Funkcje, które wykorzystywali
±my w ostatnim programie oczywi±cie bior¡ to pod uwag¦ i zarówno kopiowanie jak i
konkatenacja prawidªowo zachowuje znak ko«ca napisu w docelowym ªa«cuchu. Przy przy
obliczaniu miejsca w tablicach znakowych pami¦tajmy o dodatkowej komórce na '\0'.
Do obliczania dªugo±ci ªa«cucha (nie wliczaj¡c jednak znaku jego ko«ca) sªu»y funkcja
strlen():
#include <s t d i o . h>
2 #include <s t r i n g . h>
4 int main ( ) {
/ 11 znakow to za malo ! Pamietajmy o '\0 ' /
6 char napi s [ 1 2 ] = "He l l o World" ;
/ Blad prog rami s ty ! /
8 char za_krotki [ 1 1 ] = "He l l o World" ;
10 p r i n t f ( "Dlugosc napi su \"%s \" to %d\n" , napi s , s t r l e n ( napi s ) ) ;
p r i n t f ( "Czy to ten napi s : %s ?\n" , za_krotki ) ;
12 return 0 ;
}
W powy»szym przykªadzie programista popeªniª bª¡d polegaj¡cy na przydzieleniu zbyt
maªej tablicy - zabrakªo w niej miejsca na znak '\0'. W wyniku tego ostatnie wywoªanie
mo»e powodowa¢ niespodziewane efekty. W tym konkretnym przypadku najprawdopodobniej
zostanie jedynie wy±wietlony podwójny napis Hello World (dzieje si¦ tak, gdy»
zmiennym zadeklarowanym jedna po drugiej zazwyczaj zostaje przydzielony s¡siaduj¡cy
obszar pami¦ci a funkcja printf() wy±wietla znaki a» do napotkania \0). W ogólno-
±ci jednak w s¡siaduj¡cym obszarze mogªyby znajdowa¢ si¦ przypadkowe warto±ci i na
ekranie obserwowaliby±my ±mieci lub program mógªby przesta¢ dziaªa¢.
18
3. ZMIENNE I TYPY DANYCH
Zapami¦taj! Do wypeªniania i kopiowania ªa«cuchów u»ywaj funkcji takich jak
strcpy(), nie za± operatora przypisania. Wyj¡tkiem jest inicjalizacja w miejscu deklaracji.
Ka»dy napis uj¦ty w cudzysªów ma niejawnie doª¡czony znak ko«ca ªa«cucha
w postaci znaku 'n0'
19
Rozdziaª 4
Operatory, arytmetyka, konwersje
Bie»¡cy rozdziaª omawia podstawowe operatory j¦zyka C, ich priorytety oraz zagadnienia
takie jak arytmetyka liczbowa, konwersje i promocje. Operatory s¡ podstawow¡ cegieªk¡
sªu»¡c¡ do budowania instrukcji j¦zyka C. Ka»dy operator ma okre±lon¡ liczb¦ operand
ów lub inaczej argumentów, na których dziaªa. Liczb¦ t¦ nazywamy jego arno±ci¡. W
C mamy operatory jednoargumentowe (unarne), dwuargumentowe (binarne) oraz (ciekawostka)
jeden operator trójargumentowy (ternarny), którego nie b¦dziemy omawia¢.
Operatory najwygodniej rozpatrywa¢ w grupach. Zaznaczam, »e grup¦ operatorów bitowych
celowo, dla prostoty w tym skrypcie pomijam.
4.1 Operatory arytmetyczne
Zacznijmy od grupy operatorów arytmetycznych. Mamy w niej binarne operatory dodawania
(+), odejmowania (-), mno»enia (*), dzielenia (/) i operator modulo (%) czyli
reszta z dzielenia. Mam nadziej¦, »e jako takie nie wymagaj¡ wyja±nienia. Na przykªadzie
poka»emy jednak, jakie puªapki czyhaj¡ na nie±wiadomych programistów przy ich
u»ywaniu:
1 #include <s t d i o . h>
3 int main ( ) {
int a = 1 , b = 2 , c = 3 ;
5 double y = 7 . 0 , z ;
z = c / b ;
7 p r i n t f ( " Dz i e l e n i e ( c a l k owi t o l i c zbowe ) %f \n" , z ) ;
z = (double ) c / b ;
9 p r i n t f ( " Dz i e l e n i e ( zmiennopozycyjne ) %f \n" , z ) ;
p r i n t f ( "Czesc c a lkowi t a d z i e l e n i a %d\n" , ( int ) z ) ;
11 p r i n t f ( "Modulo %d\n" , c / b ) ;
4. OPERATORY, ARYTMETYKA, KONWERSJE
z = (double ) ( c / b ) ;
13 p r i n t f ( "Uwaga ! znow d z i e l e n i e ( c a l k owi t o l i c zbowe ) %f \n" , z ) ;
return 0 ;
15 }
Rozwa»my lini¦ 6. Dzielimy dwie liczby caªkowite. Spodziewamy si¦ warto±ci zmiennopozycyjnej
wi¦c wynik przypisujemy do zmiennej odpowiedniego typu. Tutaj mamy jednak
niespodziank¦.
Zapami¦taj! W j¦zyku C istniej¡ dwie arytmetyki: caªkowitoliczbowa i zmiennopozycyjna.
Je±li oba operandy s¡ caªkowite to wynik operacji arytmetycznych te» jest
liczb¡ caªkowit¡.
Jak wi¦c poradzi¢ sobie przy dzieleniu dwóch liczb caªkowitych? Wystarczy tymczasowo
zmieni¢ typ cho¢ jednego z jego operandów. Taka tymczasowa zmiana typu nosi nazw
¦ rzutowania. Unarny operator rzutowania, to nazwa typu do którego konwertujemy,
umieszczona w nawiasach, wyst¦puj¡cy tu» przed rzutowanym wyra»eniem (linia 8). Gdy
jeden z operandów, jest typu wi¦kszego", podanego jawnie przez rzutowanie lub explicite
wprost w deklaracji, a drugi jest typu mniejszego wówczas nast¦puje jego (niejawna)
promocja. Przykªadowo: gdy jeden z operandów jest typu double a drugi int to drugi
jest konwertowany (promowany) do typu double (linia 8). Zauwa»my »e promocja zawsze
jest bezpieczna, bo nie wi¡»e si¦ z utrat¡ informacji. Rzutowa¢ mo»na natomiast na
typ mniejszy i wówczas musimy by¢ ±wiadomi mo»liwo±ci utraty informacji. Czasami
mo»e to by¢ ±wiadomy zabieg, tak jak w linii 10. Jeszcze jedna uwaga dotycz¡ca wªa±ciwego
stosowania rzutowania. Kod z linii 13 daje wynik caªkowitoliczbowy, bo najpierw
dokonana jest operacja dzielenia (caªkowitoliczbowego, bo oba operandy s¡ caªkowitoliczbowe),
a pó¹niej ten wynik (caªkowitoliczbowy) jest rzutowany na double. Nie o taki
efekt zapewne chodziªo. Poza wymienionymi drobnymi puªapkami, rzutowania i promocje
s¡ zgodne z naszymi intuicyjnymi oczekiwaniami.
W grupie operatorów arytmetycznych mamy jeszcze operatory pre- i post- inkrementacji
oraz pre- i post- dekrementacji, sªu»¡ce do szybkiego zwi¦kszania i zmniejszania
warto±ci caªkowitych o jeden. Przyjrzyjmy si¦ ró»nicy w dziaªaniu operatorów z grupy
pre od post:
1 #include <s t d i o . h>
3 int main ( ) {
int a , b ;
5 / Preinkrementacja /
a = 5 ;
7 b = ++a ;
p r i n t f ( "b = %d , a = %d\n" , b , a ) ;
21
4. OPERATORY, ARYTMETYKA, KONWERSJE
9 / Pos t ink r ementac ja /
a = 5 ;
11 b = a++;
p r i n t f ( "b = %d , a = %d\n" , b , a ) ;
13 return 0 ;
}
Jak mo»emy obserwowa¢ na wydruku operator preinkrementacji najpierw dokonuje zwi¦kszenia
operandu o jeden a potem zwraca zwi¦kszon¡ warto±¢. Operator z grupy post najpierw
zwraca bie»¡c¡ warto±¢ operandu (która jest wykorzystywana do dalszych oblicze«)
a pó¹niej dokonuje zwi¦kszenia o jeden. Operatory inkrementacji (dekrementacji) oprócz
szybko±ci pozwalaj¡ na kompaktowy zapis czynno±ci, która inaczej potrzebowaªaby kilku
instrukcji, na przykªad: element = tablica[i--]; Nale»y bezwzgl¦dnie unika¢ instrukcji,
w których wyst¦puje kilka operatorów inkrementacji (dekrementacji) operuj¡cych na
tym samym obiekcie: a = a-- - --a. Efekt takiej operacji jest niezdeniowany.
4.2 Operatory relacyjne, prawda i faªsz
Operatory relacyjne to operatory, które na ró»ne sposoby porównuj¡ swoje operandy
(==, !=, <, >, <=, >= ). Co powinno by¢ wynikiem tego porównania? Odpowiemy
natychmiast, »e prawda lub faªsz. Problem jednak jest taki, »e w j¦zyku C nie ma osobnego
typu, który jawnie odpowiadaªby wynikom dziaªania operatorów relacyjnych z ich
mo»liwymi warto±ciami: prawd¡ lub faªszem. W wielu j¦zykach jest to typ boolean. Zamiast
tego przyjmuje si¦ w j¦zyku C nast¦puj¡c¡ konwencj¦.
Zapami¦taj! Faªsz jest reprezentowany przez warto±¢ zero, natomiast prawd¦ reprezentuj
¡ pozostaªe, niezerowe warto±ci.
Aby±my mogli ilustrowa¢ materiaª przykªadami, to w tym miejscu do dalszej nauki niezb
¦dna b¦dzie instrukcja warunkowa. Jest ona na tyle prosta, »e czytelnik bez trudu j¡ zrozumie:
blok instrukcji jest wykonywany, je±li wyra»enie w nawiasie po sªowie kluczowymif
jest prawdziwe.
#include <s t d i o . h>
2
int main ( ) {
4 int x = 16 , w;
i f ( x % 2 == 0) {
6 p r i n t f ( "x j e s t l i c z b a par zys ta \n" , x ) ;
}
8 / Operator : nieprawda , ze rowny /
i f ( x % 2 != 0) {
22
4. OPERATORY, ARYTMETYKA, KONWERSJE
10 p r i n t f ( "x j e s t l i c z b a ni epa r z y s t a \n" , x ) ;
}
12 w = x % 2 ;
/ Uwaga /
14 i f (w = 1) {
p r i n t f ( "x j e s t l i c z b a ni epa r z y s t a \n" , x ) ;
16 }
}
Przykªad ilustruje nie tylko dziaªanie operatora porównania == ale tak»e bardzo, bardzo
cz¦sty bª¡d (pojawiaj¡cy si¦ nawet u do±wiadczonych programistów). Bª¡d polega na
pomyleniu operatora porównania == z operatorem przypisania =. Poniewa» w C nie ma
typu boolowskiego, nie mo»emy spodziewa¢ si¦ pomocy od kompilatora, który w takim
wypadku mógªby zasygnalizowa¢ na przykªad niepoprawne u»ycie instrukcji warunkowej.
Bª¡d nie jest sygnalizowany gdy» operator przypisania te» zwraca warto±¢! Jest nim
warto±¢ wyra»enia stoj¡cego po prawej jego stronie. Do tej kwestii wrócimy jeszcze przy
omawianiu operatorów z grupy przypisania.
Zapami¦taj! Operator porównania to == a operator przypisania to = . Ich mylenie
(nawet przez zwykª¡ literówk¦) jest bardzo cz¦stym bª¦dem programisty.
4.3 Operatory logiczne
Operatory logiczne pozwalaj¡ na ª¡czenie operatorów relacyjnych w bardziej zªo»one konstrukcje.
Mo»emy zapyta¢ na przykªad kiedy zachodz¡ dwa warunki lub przynajmniej
jeden z nich. S¡ to operatory logiczne
 and (polski spójnik i ) zwracaj¡cy prawd¦ gdy oba jego operandy s¡ prawdziwe,
oznaczany &&
 or (polski spójnik lub) zwracaj¡cy prawd¦ gdy jeden z jego operandów jest prawdziwy,
oznaczany ||.
Mamy jeszcze jednoargumentowy operator logicznego przeczenia not, oznaczany !. Szczeg
ólnie przy operatorach logicznych pami¦tajmy o tym, co jest uznawane za prawd¦ a co
za faªsz. Kod w j¦zyku C umo»liwia bardzo kompaktowy zapis kilku czynno±ci w jednej
instrukcji, co wytrawni programi±ci C cz¦sto wykorzystuj¡. Przykªad u»ycia oraz puªapka
(a jak»e!) w poni»szym przykªadzie:
1 #include <s t d i o . h>
3 int main ( ) {
int x = 3 , y = 2 , z = 1 ;
23
4. OPERATORY, ARYTMETYKA, KONWERSJE
5 i f ( x >= y && x >= z ) {
p r i n t f ( "x j e s t najwi eks za spos rod %d,%d,%d\n" , x , y , z ) ;
7 }
i f ( x % 2 | | y % 2 | | z % 2) {
9 p r i n t f ( "Choc jedna z l i c z b %d,%d,%d j e s t par zys ta \n" , x , y , z ) ;
}
11 / Uwaga /
i f ( ....x | | ++y ) {
13 p r i n t f ( "Czy wi e s z dl a c z e g o y ma wciaz war tosc %d?\n" , y ) ;
}
15 / Uwaga /
i f (....z && ++y ) {
17 p r i n t f ( "Tego komunikatu ni e zobac zys z na e k r ani e \n" ) ;
}
19 p r i n t f ( "Czy wi e s z dl a c z e g o y ma wciaz war tosc %d?\n" , y ) ;
return 0 ;
21 }
Je±li odpowiedziaªe± tak na dwa zadane w programie pytania, to nie musisz czyta¢ wyja-
±nienia. Cho¢ w zasadzie powiniene± sprawdzi¢ czy poprawnie rozumujesz. Puªapka tkwi
w sposobie w jakim s¡ ewaluowana (inaczej: wyliczane) wyra»enia z operatorami logicznymi.
Zasada jest prosta cho¢ trzeba oczywi±cie o niej wiedzie¢ »eby unikn¡¢ puªapek.
Zapami¦taj! Przy wyliczaniu warto±ci operatora logicznego najpierw wyliczany jest
jego lewy operand. Je±li z jego warto±ci wynika ju» jaka jest warto±¢ caªego wyra»enia
to drugi operand nie jest ju» wyliczany
Mam nadziej¦, »e powy»sze stwierdzenie w wystarczaj¡cy sposób wyja±nia dlaczego warto
±¢ zmiennej y w programie pozostaªa niezmieniona.
4.4 Operatory przypisania
Do opisania pozostaªa jeszcze grupa operatorów przypisania. Oprócz samego operatora
przypisania = zaliczamy te» do tej grupy -=, *=, /=, %= ... Operatory te s¡ skrótowym
zapisem dla operacji przypisania i tej która wyst¦puje w ich symbolu: x -= y jest
skrótem dla x = x - y; x %= y jest skrótem dla x = x % y. U»ycie tych operatorów
jest na tyle proste, »e nie b¦dziemy go ilustrowa¢ przykªadem. Podam natomiast wa»n¡
zasad¦ dla tej grupy, z której bardzo cz¦sto korzystamy w praktyce:
Zapami¦taj! Operatory przypisania te» zwracaj¡ warto±¢. Jest to warto±¢ stoj¡ca
po ich prawej stronie.
24
4. OPERATORY, ARYTMETYKA, KONWERSJE
Tutaj przyda si¦ maªy przykªad:
1 #include <s t d i o . h>
#include <s t r i n g . h>
3 int main ( ) {
char password [ 1 0 ] ;
5 int a c c e s s ;
p r i n t f ( "Podaj ha s l o : " ) ;
7 s c anf ( "%s " , password ) ;
i f ( ( a c c e s s = strcmp ( password , " s e c r e t " ) ) != 0) {
9 p r i n t f ( "Acces s denied \n" ) ;
return ;
11 } / d a l s z y kod moze k o r z y s t a c ze zmiennej a c c e s s /
return 0 ;
13 }
Jak nale»y rozumie¢ warunek w instrukcji if? Otó» najpierw (kolejno±¢ wyznaczona
przez nawiasy) nast¦puje wywoªanie funkcji strcmp sªu»¡cej do porównywania ªa«cuchów.
Jej wynik to warto±¢ 0 (ªa«cuchy równe), liczba dodatnia (ªa«cuch pierwszy wi¦kszy od
drugiego) lub liczba ujemna (ªa«cuch drugi wi¦kszy od pierwszego). Nast¦pnie warto±¢ z
funkcji jest przypisywana do zmiennej access. Dalej, zgodnie z podan¡ zasad¡ warto±¢
zwrócona z strcmp() jest warto±ci¡ caªej operacji przypisania. Jest ona porównywana
(operator !=) do 0 i rezultat tego porównania jest wykorzystany w instrukcji warunkowej.
4.5 Priorytety
Zajmiemy si¦ teraz spraw¡ wyznaczania kolejno±ci wykonywania dziaªa« w przypadku gdy
w jednym wyra»eniu mamy wiele operatorów. Nale»y pami¦ta¢, »e nadrz¦dne znaczenie
ma kolejno±¢ wyznaczona przez nawiasy i w razie w¡tpliwo±ci nale»y je stosowa¢. Czytelnik
zdecydowanie powinien jednak pozna¢ podstawowe reguªy ª¡czno±ci i priorytety
operatorów aby móc analizowa¢ cudzy kod oraz pisa¢ wªasny, zgodny z pewnymi niepisanymi
standardami. Kod z du»¡ ilo±ci¡ niepotrzebnych nawiasów, mo»e wr¦cz utrudnia¢
czytanie programu. Reguªy dla poznanych wcze±niej operatorów s¡ raczej proste i zgodne
z intuicj¡.
Je±li w wyra»eniu wyst¦puje wiele operatorów, to o kolejno±ci ich wykonania decyduje
w pierwszej kolejno±ci priorytet. Priorytety ªatwo mo»emy zapami¦ta¢ w postaci
zdania Jedzie Andrzej Rowerem Ledwo Pedaªuj¡c. Pomysª powiedzonka o priorytetach
oraz jego fragment zaczerpn¡ªem z doskonaªej ksi¡»ki Bruce Eckela Thinking in Java.
Zdrad¹my zatem jak rozumie¢ powiedzonko. Otó» pierwsze litery wyrazów wskazuj¡ grupy
operatorów wg malej¡cych priorytetów:
Jednoargumentowe, Arytmetyczne, Relacyjne, Logiczne, Przypisania.
25
4. OPERATORY, ARYTMETYKA, KONWERSJE
Taki porz¡dek priorytetów zdaje si¦ by¢ zgodny z naszym sposobem my±lenia arytmetycznego:
najpierw liczymy rzeczy drobne (jednoargumentowe, --a), wykonujemy
na nich operacje arytmetyczne (-- a * 2), pó¹niej wyliczone wielko±ci porównujemy (
--a * 2 > --b ) i wyniki u»ywamy do budowy bardziej skomplikowanych warunków (
--a * 2 > --b && a - b > 0 ). Jestem przekonany, »e gdyby czytelnik dostaª ostatnie
wyra»enie do wyliczenia, to nawet nie znaj¡c reguª priorytetów, podaª by wªa±ciw¡
kolejno±¢ ewaluacji.
Uwag¦ jednak nale»y zwróci¢ na grup¦ operatorów przypisania. Grupa przypisania
ma priorytet najni»szy - gdy wszystko ju» policzyli±my dokonujemy przypisania. W tym
miejscu bardzo prosz¦ czytelnika o wykonanie nast¦puj¡cego ¢wiczenia (pilniejsi czytelnicy
powinni poprawnie przewidzie¢, bez uruchamiania programu, jaka b¦dzie warto±¢
zmiennej a).
.wiczenie 4.1 Napisz program sprawdzaj¡cy warto±¢ zmiennej caªkowitej a, po wykonaniu
nast¦puj¡cej instrukcji a = 2 && 3 < 1.
Otó» zgodnie z obowi¡zuj¡cym priorytetem operatorów, nawiasowanie w tym wyra»eniu
jest nast¦puj¡ce: a = ( 2 && (3 < 1)! Mamy tak¡ ewaluacj¦: relacyjne (3 < 1),
logiczne (2 && 0), przypisania (a = 0). Na t¦ spraw¦ trzeba zwraca¢ uwag¦ przy wyra»eniach
z przypisaniem: operator przypisanie ma co prawda ni»szy priorytet ni» relacyjny,
jednak bardzo cz¦sto potrzeba kolejno±ci odwrotnej! Poni»szy przykªad jest kolejn¡ ilustracj
¡ tej subtelnej puªapki, w któr¡ wpadaj¡ nawet zaawansowani programi±ci:
1 #include <s t d i o . h>
#include <s t r i n g . h>
3
int main ( ) {
5 char w_alfa [ 5 ] = " a l f a " ;
char w_beta [ 5 ] = " beta " ;
7 int por ;
i f ( por = strcmp (w_alfa , w_beta ) != 0) {
9 p r i n t f ( "Wynik (musi byc < 0 ) : %d\n" , por ) ;
p r i n t f ( "Sprawdzam: %d\n" , strcmp (w_alfa , w_beta ) ) ;
11 }
return 0 ;
13 }
Oczywi±cie aby otrzyma¢ prawidªowy wynik nale»y u»y¢ nawiasów tak, jak zostaªo to
zrobione we wcze±niejszym przykªadzie z funkcj¡ strcmp().
Zapami¦taj! Operator przypisania ma bardzo niski priorytet, co w wyra»eniach z
operatorami relacyjnymi i logicznymi mo»e prowadzi¢ do niespodziewanych wyników.
Niezb¦dne jest tu u»ycie nawiasów.
26
4. OPERATORY, ARYTMETYKA, KONWERSJE
4.6 .¡czno±¢ i pozostaªe zasady
Zajmiemy si¦ teraz odpowiedzi¡ na pytanie jaki jest porz¡dek wykonywania dziaªa« gdy
w wyra»eniu wyst¦puj¡ operatory o tym samym priorytecie. Tutaj decyduj¡ gªównie zasady
ª¡czno±ci. .¡czno±¢ wskazuje kierunek w jakim wyra»enie jest ewaluowane: od lewej
(ª¡czno±¢ lewostronna) czy od prawej (ª¡czno±¢ prawostrona). Zasady ª¡czno±ci s¡ nast¦-
puj¡ce, przy uwzgl¦dnieniu zarówno poznanych ju» operatorów jak i tych, wprowadzonych
w dalszych rozdziaªach:
1. prawostronna: unarne przedrostkowe ( !, *, & ), pre-{inkrementacja, dekrementacja},
rzutowanie, operatory grupy przypisania
2. lewostronna: arytmetyczne i pozostaªe, w tym unarne przyrostkowe ( [], .,-> ),
post-{inkrementacja, dekrementacja}, wywoªanie funkcji
Przykªady ewaluacji zgodnie z powy»sz¡ reguª¡:
x = y = z = 7 wylicza si¦ x = (y = (z = 7))
x - y - z wylicza si¦ jako (x - y) - z .
Jako ¢wiczenie czytelnik sprawdzi jak¡ warto±¢, dla zmiennej z = 7 , maj¡ wyra»enia:
z - z - z oraz z - (z - z)
W grupie binarnych operatorów arytmetycznych wy»szy priorytet maj¡ operatory z
grupy mno»enia (*, /, %).
Doda¢ nale»y jeszcze jedn¡ zasad¦, która ustala kolejno±¢ w grupie operatorów unarnych:
przyrostkowe maj¡ wy»szy priorytet ni» przedrostkowe. Stosowanie tej zasady
cz¦sto spotka¢ mo»emy w praktyce (to znaczy brak jest nawiasów) na przykªad w takich
wyra»eniach:
*x-- jest wyliczane jako *(x--)
&struktura.pole jest wyliczane jako &(struktura.pole)
*struktura.wsk jest wyliczane jako *(struktura.wsk)
Operatory *, &, . zostan¡ wprowadzone pó¹niej lecz dla porz¡dku umieszczamy je tutaj
z nadziej¡, »e czytelnik powróci do tego rozdziaªu (autor postara si¦ przypomnie¢ mu o
tym).
Dobrn¦li±my do ko«ca tego technicznego i by¢ mo»e troch¦ nudnego rozdziaªu. Czytelnik
pisz¡c wªasne programy z pewno±ci¡ nabierze wprawy i po kilku próbach, równie»
przeprowadzonych w my±lach, nawiasowanie nie b¦dzie stanowiªo dla niego problemu. Nale
»y te» pami¦ta¢ o tym, »e ka»dy j¦zyk programowania musi okre±la¢ priorytety i reguªy
ª¡czno±ci dla swoich operatorów. Podstawowe reguªy, które czytelnik tu poznaª obowi¡-
zuj¡ w du»ym stopniu na przykªad w j¦zyku Java, C# (dla operatorów, które w tych
j¦zykach wyst¦puj¡) i oczywi±cie C++.
27
Rozdziaª 5
Instrukcje steruj¡ce
Przyszedª czas na pisanie kodu, którego przepªywem mo»emy sterowa¢ w sposób bardziej
skomplikowany. Do tej pory brakowaªo konstrukcji umo»liwiaj¡cych warunkowe wykonanie
kodu, czyli instrukcji warunkowych (u»wali±my instrukcji if w stopniu podstawowym),
oraz mo»liwo±ci wielokrotnego, równie» warunkowego, powtarzania caªego bloku
kodu czyli p¦tli. Posªugiwanie si¦ p¦tlami jest absolutnie konieczne do pisania programów
na poziomie wy»szym ni» caªkowicie podstawowy.
5.1 Instrukcje warunkowe
Z instrukcj¡ warunkow¡ spotkali±my si¦ ju» w poprzednim rozdziale. Instrukcja if pozwala
warunkowo wykonywa¢ bloki kodu. Najbardziej ogólna jej posta¢ jest nast¦puj¡ca:
if (warunek) {
ci¡g instrukcji wykonywanych gdy warunek jest speªniony;
}
else {
ci¡g instrukcji wykonywanych gdy warunek nie jest speªniony;
}
Nale»y zaznaczy¢, »e blok instrukcji ze sªowem kluczowym else jest opcjonalny, to znaczy
mo»e go w ogóle nie by¢. Ponadto bardzo cz¦sto stosuje si¦ zagnie»d»anie instrukcji if,
tak jak w poni»szym przykªadzie:
1 #include <s t d i o . h>
int main ( ) {
3 int cena ;
p r i n t f ( "Podaj cene swojego samochodu w tys . : " ) ;
5 s c anf ( "%d" , &cena ) ;
i f ( cena < 20) {
5. INSTRUKCJE STERUJCE
7 p r i n t f ( " Ni ewi e l k i i uzywany\n" ) ;
}
9 el se
i f ( cena < 40) {
11 p r i n t f ( "Uzywany kl a sy kompakt lub nowy maluch\n" ) ;
}
13 el se
i f ( cena < 80) {
15 p r i n t f ( "Uzywany kl a sy s r e d n i e j lub nowy kompakt\n" ) ;
}
17 el se
p r i n t f ( "Masz zapewne mowy samochod kl a sy s r e d n i e j \n" ) ;
19 return 0 ;
}
Zauwa»my, »e dzi¦ki zagnie»d»eniu instrukcji if oraz wªa±ciwemu doborowi warunków (od
warto±ci najmniejszej do najwi¦kszej) uzyskali±my efekt przedziaªów warto±ci. Ponadto
ujmowanie bloku instrukcji w nawiasy klamrowe jest opcjonalne. Nie wyst¦puj¡ w linii
10 oraz 18. Mamy tutaj zasad¦, stosowan¡ równie» w p¦tlach.
Zapami¦taj! Je±li w instrukcji if lub w p¦tli nie ma nawiasów klamrowych ograniczaj
¡cych blok do wykonania wewn¡trz nich, to jako ich ciaªo brana jest jedynie
pierwsza, wyst¦puj¡ca bezpo±rednio, instrukcja. Cz¦sto jest to inna p¦tla lub instrukcja
warunkowa.
U»ywanie tych konstrukcji bez nawiasów wymaga jednak wprawy. Zwró¢my uwag¦ równie
» na wci¦cia, które pomagaj¡ programi±cie prze±ledzi¢ zagnie»d»enie.
Czytelnik zauwa»a zapewne, »e gdyby±my zechcieli w ostatnim przykªadzie wprowadzi
¢ du»o wi¦cej przedziaªów warto±ci, to nasz kod staªby si¦ bardzo nieczytelny i trudny
w piel¦gnowaniu. Wªa±nie dla uªatwienia pisania tego typu kodu wprowadzono instrukcj¦
switch. Je±li potramy tak sformuªowa¢ nasz problem, »e decyzje, który blok instrukcji
ma by¢ wykonany (lub który przedziaª zostaª wybrany) da si¦ okre±li¢ za pomoc¡ warto
±ci caªkowitej (czasami wymaga to pomysªowo±ci), to mo»emy skorzysta¢ z uªatwienia,
które oferuje instrukcja switch. Oto jej ogólna budowa:
switch (wyra»enie_caªkowite) {
case warot±¢1:
ci¡g instrukcji1;
...
break;
case warto±¢2:
ci¡g instrukcji2;
29
5. INSTRUKCJE STERUJCE
...
break;
case ...
default:
ci¡g instrukcjiDefault;
}
Przykªadowo, je±li wyra»enie_caªkowite ma warto±¢ równ¡ warto±¢2 to wykonywany
jest ci¡g instrukcji2 a» do napotkania pierwszego sªowa kluczowego break lub te»
ko«ca instrukcji switch. Je»eli wyra»enie_caªkowite nie wylicza si¦ do »adnej z warto±ci
po case, to wykonywane s¡ instrukcje po default. Samo default te» jest opcjonalne.
Oto jak mo»na przepisa¢ poprzedni przykªad z wykorzystaniem switch:
#include <s t d i o . h>
2 int main ( ) {
int cena ;
4 p r i n t f ( "Podaj cene swojego samochodu w tys . : " ) ;
s c anf ( "%d" , &cena ) ;
6 switch ( cena / 20) {
case 0 :
8 p r i n t f ( " Ni ewi e l k i i uzywany\n" ) ;
break ;
10 case 1 :
p r i n t f ( "Uzywany kompakt\n" ) ;
12 break ;
case 2 :
14 p r i n t f ( "Uzywany s r edni ak \n" ) ;
break ;
16 default :
p r i n t f ( "Masz zapewne nowy samochod\n" ) ;
18 }
return 0 ;
20 }
Zapami¦tajmy tutaj wa»n¡ kwesti¦: sªowo kluczowe break jest opcjonalne po case i cho¢
najcz¦±ciej, w praktyce, b¦dziemy go w tym miejscu potrzebowa¢, to musimy pami¦ta¢ o
jego wstawieniu.
Zapami¦taj! Nie zapominaj o u»yciu sªowa kluczowego break w instrukcji switch.
Czytelnik wykona eksperyment i zaobserwuje efekt po usuni¦ciu z kodu case 2: instrukcji
break i podaniu ceny 45 tys.
30
5. INSTRUKCJE STERUJCE
5.2 P¦tle
P¦tle sªu»¡ do wielokrotnego wykonywania bloku instrukcji. Mamy trzy rodzaje p¦tli w
j¦zyku C. Wszystkie s¡ sobie równowa»ne, jednak wygoda przes¡dza o stosowaniu konkretnego
rodzaju p¦tli w okre±lonej sytuacji. W ka»dym rodzaju p¦tli musimy poda¢
warunek jej wykonywania - p¦tla dziaªa tak dªugo, jak dªugo warunek jest prawdziwy,
czyli inaczej, wyra»enie, które go opisuje wylicza si¦ do warto±ci niezerowej. Zacznijmy
od p¦tli while. Jej posta¢ jest nast¦puj¡ca:
while (warunek_wykonywania) {
instrukcja1;
instrukcja2;
...
}
P¦tl¦ while wygodnie stosowa¢ w sytuacjach, w których nie znamy ilo±ci wykona« p¦tli
w momencie jej uruchamiania. Przykªadem mo»e by¢ sczytywanie linii (czy znaków) z
pliku tekstowego lub danych binarnych z gniazda sieciowego. W poni»szym programie
b¦dziemy sczytywa¢ dane od u»ytkownika. Petla jest wykonywana tak dªugo jak dªugo
wyra»enie w nawiasie po while jest prawdziwe:
#include <s t d i o . h>
2 int main ( ) {
int l i c z b a ;
4 int szukana = 7 ;
int koni e c = 1 ;
6 p r i n t f ( " Zgadni j l i c z b e od 0 do 10 : " ) ;
while ( koni e c ) {
8 s c anf ( "%d" , &l i c z b a ) ;
i f ( l i c z b a == szukana ) koni e c = 0 ;
10 el se
i f ( l i c z b a > szukana ) p r i n t f ( "Za duzo ! : " ) ;
12 el se p r i n t f ( "Za malo ! : " ) ;
}
14 p r i n t f ( "Bingo ! \ n" ) ;
return 0 ;
16 }
Mam nadziej¦, »e czytelnikowi udaªo si¦ zgadn¡¢ i nie musiaª przerywa¢ dziaªania programu
kombinacj¡ klawiszy Ctrl-c. Zwró¢my uwag¦ na konieczno±¢ inicjalizacji zmiennej
koniec, która steruje wykonaniem p¦tli oraz na zagnie»d»one instrukcje if i brak nawias
ów klamrowych w niektórych z nich.
31
5. INSTRUKCJE STERUJCE
Je±li ilo±¢ wykona« (powtórze«, iteracji) jest (lub b¦dzie) znana w momencie uruchamiania
p¦tli, to prawdopodobnie najlepsza b¦dzie p¦tla for. P¦tla for posiada wsparcie
do obsªugi licznika - zmiennej, która b¦dzie odliczaªa liczb¦ powtórze« p¦tli.
for( inicjalizacja_licznika; warunek_wykonywania; obsªuga_licznika){
instrukcja1;
instrukcja2;
...
}
Omówimy j¡ teraz na prostym przykªadzie. Naszym zadaniem b¦dzie policzenie sumy
liczb caªkowitych podanych przez u»ytkownika. U»ytkownik na pocz¡tku podaje ilo±¢
sumowanych liczb:
#include <s t d i o . h>
2 int main ( ) {
int l i c z b a_i t e r a c j i , i ;
4 int l i c zba_bi e z a c a ;
int suma = 0 ;
6 p r i n t f ( " I l e l i c z b do sumowania : " ) ;
s c anf ( "%d" , &l i c z b a_i t e r a c j i ) ;
8 for ( i = 0 ; i < l i c z b a_i t e r a c j i ; i++){
p r i n t f ( " Skladnik sumy : " ) ;
10 s c anf ( "%d" , &l i c zba_bi e z a c a ) ;
suma = suma + l i c zba_bi e z a c a ;
12 }
p r i n t f ( "Suma : %d\n" , suma ) ;
14 return 0 ;
}
W nawiasie po sªowie for podajemy kolejno i rozdzielamy ±rednikiem: wyra»enie inicjuj
¡ce licznik p¦tli, nast¦pnie warunek jej wykonywania (i tym samym zako«czenia) oraz
wyra»enie modykuj¡ce licznik w ka»dej iteracji. Warunek wykonywania sprawdzany jest
przed ka»d¡ iteracj¡ a modykacja licznika tu» po jej zako«czeniu. Oto kolejny przykªad
wykorzystuj¡cy p¦tl¦ for:
1 #include <s t d i o . h>
#include <s t r i n g . h>
3 int main ( ) {
int i ;
5 char napi s [ 1 0 0 ] = "C r u l e s ! " ;
for ( i = 0 ; i < s t r l e n ( napi s ) ; i++){
7 p r i n t f ( "%c \n" , napi s [ i ] ) ;
32
5. INSTRUKCJE STERUJCE
}
9 return 0 ;
}
P¦tla wywoªa funkcj¦ printf() tyle razy jaka jest dªugo±¢ napisu. Powy»szy przykªad pokazuje
jedno z typowych zastosowa« p¦tli for: odwiedzanie wszystkich elementów tablicy.
Czytelnik powinien ju» teraz zapami¦tywa¢ pewne dobrze wypróbowane konstrukcje, które
stosowane s¡ w okre±lonych sytuacjach. Jedn¡ z nich jest wªa±nie u»ywanie p¦tli for do
operacji na cz¦±ci lub wszystkich elementach tablicy.
Ostatni rodzaj p¦tli to p¦tla do-while. Jedyna ró»nica w stosunku do p¦tli while
jest taka, »e niezale»nie od prawdziwo±ci sprawdzanego warunku p¦tla zawsze wykona
przynajmniej jedn¡ iteracj¦:
#include <s t d i o . h>
2
int main ( ) {
4 int l i c z b a = ..1;
do {
6 p r i n t f ( "Podaj par zys ta l i c z b e : " ) ;
s c anf ( "%d" , &l i c z b a ) ;
8 } while ( l i c z b a % 2 != 0 ) ;
return 0 ;
10 }
Jest wielu programistów, którzy rzadko u»ywaj¡ p¦tli do-while.
.wiczenie 5.1 Dla p¦tli for z poprzednich przykªadów napisa¢ równowa»ne im p¦tle
while oraz do-while.
Z p¦tlami zwi¡zane jest jeszcze u»ycie instrukcji break oraz continue.
 break powoduje natychmiastowe zako«czenie dziaªania p¦tli bez wzgl¦du na warunki
steruj¡ce i dalsze instrukcje. Mówimy wtedy, »e wyskakujemy z p¦tli. W
przypadku p¦tli zagnie»d»onych wyskakujemy jedynie z p¦tli najbli»szej, w której
break wyst¦puje.
 continue przerywa natomiast bie»¡c¡ iteracj¦ i kontynuuje wykonywanie p¦tli od
pierwszej jej instrukcji.
Poni»szy program ilustruje u»ycie tych sªów kluczowych. Zadaniem programu jest wyznaczenie
najwi¦kszego nieparzystego dzielnika dla wczytanej liczby dodatniej. Dla prze-
±ledzenia dziaªanie programu w my±lach, mo»na poda¢ liczby 12 i 18.
33
5. INSTRUKCJE STERUJCE
#include <s t d i o . h>
2 int main ( ) {
int l i c z b a ;
4 int d z i e l n i k ;
p r i n t f ( "Podaj l i c z b e dodatnia : " ) ;
6 s c anf ( "%d" , &l i c z b a ) ;
d z i e l n i k = l i c z b a + 1 ;
8 while ( 1 ) {
d z i e l n i k ....;
10 i f ( l i c z b a % d z i e l n i k != 0 ) continue ;
i f ( d z i e l n i k % 2) break ;
12 }
p r i n t f ( "Najwiekszy ni epa r z y s t y d z i e l n i k : %d\n" , d z i e l n i k ) ;
14 return 0 ;
}
Czytelnik ma absolutn¡ racj¦, je±li uwa»a, »e nie jest to najbardziej efektywny sposób wyznaczenia
szukanej liczby, jednak program ma by¢ krótki i ilustrowa¢ u»ycie omawianych
sªów kluczowych. Zwró¢my ponadto uwag¦ jak wygl¡da warunek steruj¡cy p¦tli - jest
tam wyra»enie zawsze prawdziwe (zgodnie z denicj¡ prawdziwo±ci w j¦zyku C). O takich
p¦tlach mówimy, »e s¡ niesko«czone. Przydaj¡ si¦ w programach, których wykonanie
odbywa si¦ poprzez ci¡gªe powtarzanie okre±lonych czynno±ci, takich jak na przykªad nas
ªuchiwanie na gniazdach sieciowych. P¦tle niesko«czone ko«cz¡ si¦ wraz z przerwaniem
dziaªania caªego programu lub te», tak jak w naszym przypadku, gdy zaistniej¡ warunki
do wywoªania instrukcji break.
.wiczenie 5.2 Przepisa¢ p¦tle z przykªadów ilustruj¡cych u»ycie p¦tli while i do-while
korzystaj¡c z instrukcji break w p¦tli niesko«czonej.
Czasami u»ycie tych instrukcji mo»e spowodowa¢, »e kod stanie si¦ mniej czytelny i trudniejszy
w piel¦gnacji.
34
Rozdziaª 6
Tablice i struktury
Do tej pory poznali±my typy danych, które przechowywaªy pojedyncze warto±ci. Pora
teraz na konstrukcje, które pozwalaj¡ przechowywa¢ wi¦cej ni» jedn¡ warto±¢. S¡ to
tablice oraz struktury.
6.1 Tablice
Tablica sªu»y do przechowywania wi¦cej ni» jednego elementu ustalonego typu danych.
W deklaracji tablicy musimy poda¢ typ przechowywanych danych oraz ilo±¢ elementów,
na przykªad
int liczby[10];
Informacja o ilo±ci elementów jest kompilatorowi niezb¦dna, aby mógª zaalokowa¢ odpowiedni
¡ przestrze« w pami¦ci - mno»¡c ilo±¢ komórek przez rozmiar pojedynczego elementu.
Z punktu widzenia programu tablica jest po prostu ci¡gªym obszarem pami¦ci, w
dodatku takim, »e w »aden sposób nie zaznaczono jego ko«ca! Czytelnik mo»e zapyta¢
tu o tablice znakowe, które przechowuj¡ napisy i ko«cz¡ si¦ znakiem '\0'. Wynika to
jednak wyª¡cznie z konwencji przechowywania napisów a nie z samej konstrukcji tablic.
O szczegóªach implementacji tablic piszemy ju» w tym miejscu, poniewa» nast¦puj¡ca
prosta zasada pozwala unikn¡¢ wielu nieporozumie« dotycz¡cych deklaracji, inicjalizacji
i u»ycia tablic szczególnie w funkcjach:
Zapami¦taj! Przy deklaracji tablic oprócz typu przechowywanych elementów konieczna
jest informacja o ich ilo±ci. Kompilator pobiera j¡ z deklaracji b¡d¹ z wyra-
»enia inicjalizuj¡cego. W j¦zyku C nie ma uniwersalnego sposobu zaznaczania ko«ca
tablicy w pami¦ci.
Z inicjalizacj¡ tablic jest podobnie jak ze zmiennymi lokalnymi: je±li ich nie zainicjalizujemy
to zawieraj¡ przypadkowe warto±ci. Do inicjalizacji tablic u»ywamy nawiasów
klamrowych, oddzielaj¡c elementy przecinkami:
int nieparzyste[5] = {1, 3, 5, 7, 9}; - zainicjalizowana tablica 5 elementów typu
6. TABLICE I STRUKTURY
int
long pierwsze[] = {2l, 3l, 5l, 7l}; - zainicjalizowana tablica 4 elementów typu
long int, rozmiar pobrany z wyra»enia inicjalizuj¡cego
double wymierne[5] = {2.2, 3.1, 4.0 } - tablica 5 liczb typu double, przy czym
dwie ostatnie warto±ci inicjalizowane s¡ zerami.
Poni»ej pokazujemy jak mo»na w szybki sposób zainicjalizowa¢ tablic¦ zerami:
int tab[5] = {};.
Dost¦p do elementów tablicy realizuje operator indeksowania []. Do odczytania lub
zapisania elementu nale»y poda¢ jego indeks, na przykªad pierwsze[4]. Je±li chcemy
wykona¢ operacj¦ na caªej lub cz¦±ci tablicy (na przykªad przypisywanie lub wy±wietlanie
elementów) to najbardziej naturalnym sposobem jest u»ycie p¦tli for - znamy przecie»
rozmiar tablicy a tym samym ilo±¢ iteracji p¦tli. Zapami¦tajmy jednak najpierw bardzo
wa»n¡ zasad¦:
Zapami¦taj! Indeksy w tablicach rozpoczynaj¡ si¦ od 0. St¡d ostatni indeks w
tablicy jest równy rozmiar-1.
Teraz przykªad:
1 #include <s t d i o . h>
int main ( ) {
3 int tab [ 5 ] ;
int i ;
5 for ( i = 0 ; i < 5 ; i++){
s c anf ( "%d" , &tab [ i ] ) ;
7 }
for ( i = 4 ; i >= 0 ; i ....){
9 p r i n t f ( "%d " , tab [ i ] ) ;
}
11 p r i n t f ( "\n" ) ;
return 0 ;
13 }
Operator indeksowania jest operatorem unarnym przyrostkowym - ma wi¦c najwy»szy
priorytet. St¡d nie ma potrzeby u»ywania nawiasów w wyra»eniu &tab[i]. W takich wyra
»eniach wida¢, »e wysoki priorytet operatorów takich jak [] jest zgodny z oczekiwaniami
i intuicj¡ (niepotrzebne s¡ nawiasy).
W j¦zyku C istnieje mo»liwo±¢ deniowania tablic wielowymiarowych. Tablice wielowymiarowe
to wewn¦trznie pªaskie struktury danych i ci¡gªe obszary w pami¦ci, do
których dla wygody programisty zorganizowano dost¦p w postaci kilku operatorów indeksowania.
Ograniczmy si¦ w naszych rozwa»aniach do tablic dwuwymiarowych - oprócz
tablic jednowymiarowych, z nich b¦dziemy korzysta¢ najcz¦±ciej. Oto deklaracja takiej
36
6. TABLICE I STRUKTURY
tablicy:
int macierz[3][4];
Wyobra»amy j¡ sobie jako macierz z trzema wierszami i czterema kolumnami. Dost¦p do
elementu wymaga podania dwóch indeksów. Indeksy zaczynamy oczywi±cie liczy¢ od 0.
Jak zainicjalizowa¢ tak¡ tablic¦ w miejscu deklaracji? Najbardziej naturalna jest nast¦-
puj¡ca konstrukcja:
int macierz[2][3] = {{0, 1, 2}, {3, 4, 5}};
inna akceptowalna (pami¦tamy o ci¡gªym obszarze w pami¦ci oraz o inicjalizacji zerami
brakuj¡cych elementów):
int macierz[2][3] = {0, 1, 2, 3, 4};
lub nawet taka (ilo±¢ wierszy wyliczana z wyra»enia inicjalizuj¡cego) :
int macierz[][3] = {0, 1, 2, 3, 4, 5};
Te dwie ostatnie deklaracj¦ podajemy jedynie dla porz¡dku i nie radzimy ich stosowa¢
przez pocz¡tkuj¡cych. S¡ one maªo czytelne i wymagaj¡ przeliczania co stanowi wiersz
a co kolumn¦. Poni»szy przykªad ilustruje ró»ne sposoby dost¦pu do danych w tablicy
wielowymiarowej:
1 #include <s t d i o . h>
int main ( ) {
3 int macierz [ 2 ] [ 3 ] = {{0 , 1 , 2} , {3 , 4 , 5 } } ;
int i , j ;
5 int wi e r s zy = 2 ;
int kolumn = 3 ;
7 p r i n t f ( "Pierwszy wi e r s z : \ n" ) ;
for ( i = 0 ; i < kolumn ; i++){
9 p r i n t f ( "%d " , macierz [ 0 ] [ i ] ) ;
}
11 p r i n t f ( "\ nPierwsza kolumna : \ n" ) ;
for ( i = 0 ; i < wi e r s zy ; i++){
13 p r i n t f ( "%d\n" , macierz [ i ] [ 0 ] ) ;
}
15 p r i n t f ( "Cala macierz \n" ) ;
for ( i = 0 ; i < wi e r s zy ; i++) {
17 for ( j = 0 ; j < kolumn ; j++)
p r i n t f ( "%d " , macierz [ i ] [ j ] ) ;
19 p r i n t f ( "\n" ) ;
}
21 return 0 ;
}
37
6. TABLICE I STRUKTURY
Podobnie jak podawali±my to w przypadku tablic jednowymiarowych, w przypadku tablicy
dwuwymiarowej, do operacji wymagaj¡cej dost¦pu kolejno do wszystkich jej element
ów u»ywamy, ze wzgl¦du na wygod¦, dwóch zagnie»d»onych p¦tli for. Ju» w tym
miejscu wskazujemy bardzo cz¦sty bª¡d polegaj¡cy na u»ywaniu tej samej zmiennej jako
licznika przy zagnie»d»onych p¦tlach.
Zapami¦taj! U»ywaj zawsze ró»nych zmiennych jako liczników w p¦tlach zagnie»-
d»onych.
Poniewa» dobrze uczy¢ si¦ na wªasnych bªedach (lepiej ni» na cudzych) czytelnik wykona
nast¦puj¡ce ¢wiczenia:
.wiczenie 6.1 Sprawdzi¢ co si¦ stanie gdy u»yjemy tej samej zmiennej jako licznika w
p¦tlach zagnie»d»onych przy dost¦pie do tablicy dwuwymiarowej.
.wiczenie 6.2 Napisa¢ program, który dokona mno»enia dwóch macierzy, zainicjalizowanych
w miejscu deklaracji, o rozmiarach 4x2 i 2x3. Zapisa¢ wynik w kolejnej macierzy
i wy±wietli¢ j¡. Jako rozwini¦cie tego ¢wiczenia, mo»na interaktywnie poprosi¢ o podanie
rozmiarów i wczyta¢ macierze u»yte do mno»enia. W tym przypadku mo»na ograniczy¢
ilo±¢ wierszy i kolumn macierzy do, na przykªad, 5.
Na koniec uwaga, która wymaga od programisty ostro»nego u»ywania operatora indeksowania.
W j¦zyku C nie ma mechanizmów chroni¡cych przed dost¦pem poza rozmiar
tablicy, na przykªad przez podanie indeksów spoza zadeklarowanych zakresów). W wypadkach
naruszenia (zarówno do odczytu jak i zapisu) obszarów pami¦ci poza dost¦pne
dla wykonywanego programu, interweniowa¢ mo»e system operacyjny przerywaj¡c wykonywanie
programu.
6.2 Struktury
Drugim rodzajem konstrukcji pozwalaj¡cej przechowywa¢ wi¦cej ni» jedn¡ warto±¢ s¡
struktury. Zbli»amy si¦ tutaj do zagadnie«, które le»¡ u podstaw koncepcji programowania
obiektowego. Jedna z nich jest taka, »e dane opisuj¡ce jaki± byt, a przez to logicznie ze sob¡
powi¡zane, powinny wyst¦powa¢ razem. Wªa±nie owe ª¡czne wyst¦powanie danych (by¢
mo»e ró»nych typów) jest istot¡ struktur . Struktura skªada si¦ pól, które reprezentuj¡
wªa±ciwo±ci, atrybuty czy cechy omawianego bytu. Przykªadowo, je±li budujemy baz¦
danych studentów, to dla nas struktura opisuj¡ca studenta, mo»e wygl¡da¢, w du»ym
uproszczeniu, nast¦puj¡co:
struct osoba {
char imie[20];
char nazwisko[50];
38
6. TABLICE I STRUKTURY
int rok_urodzenia;
double srednia_ocen;
};
Podana wy»ej konstrukcja jest deklaracj¡ typu o nazwie struct osoba. Zwracamy uwag¦
na konieczny w tym miejscu ±rednik! Jest to do±¢ cz¦sty bª¡d skªadniowy, który jednak
przysparza kompilatorowi kªopotów w tym sensie, »e nie podaje on klarownego komunikatu
o braku tego ±rednika. Specjalnie podkre±lamy równie», »e przy u»ywaniu struktur
w deklaracjach zmiennych, argumentów funkcji itp., wymagane jest sªowo kluczowego
struct. Deklaracje zmiennych, inicjalizacje w miejscu deklaracji, dost¦p do pól struktury
zilustrowane s¡ w poni»szym przykªadzie.
#include <s t d i o . h>
2 #include <s t r i n g . h>
struct osoba {
4 char imi e [ 2 0 ] ;
int rok_urodzenia ;
6 } ;
int main ( ) {
8 struct osoba panJan = { "Jan" , 1950 } ;
struct osoba paniZos ia ;
10 struct osoba nieznajomy ;
s t r cpy ( paniZos ia . imie , " Zos ia " ) ;
12 paniZos ia . rok_urodzenia = 1992;
p r i n t f ( " Imie : " ) ;
14 s c anf ( "%s " , nieznajomy . imi e ) ;
p r i n t f ( "Rok urodz enia : " ) ;
16 s c anf ( "%d" , &nieznajomy . rok_urodzenia ) ;
p r i n t f ( "Wszystkie imiona : %s , %s , %s \n" , panJan . imie ,
18 paniZos ia . imie , nieznajomy . imi e ) ;
return 0 ;
20 }
Czytelnik zapewne zwróciª uwag¦, »e struktury mog¡ by¢ inicjalizowane w miejscu deklaracji
tak jak tablice, przy u»yciu nawiasów klamrowych. Podobnie s¡ te» traktowane
- jako ci¡gªe obszary w pami¦ci. Operator dost¦pu do pól struktury . jest, tak jak
operator indeksowania [], operatorem unarnym przyrostkowym wi¦c ma najwy»szy priorytet.
W zwi¡zku z tym nie ma potrzeby u»ywania nawiasów w wyra»eniach takich jak
&struktura.pole.
Zmienn¡ typu struct mo»emy zadeklarowa¢ równie» w miejscu denicji typu, przed
±rednikiem:
39
6. TABLICE I STRUKTURY
struct osoba {
...
} osoba1, osoba2;
Zwracamy uwag¦, »e deklaracje struktur najcz¦±ciej s¡ globalne, tak aby byªy dost¦pne
dla caªego programu. Cz¦sto umieszczane s¡ w plikach nagªówkowych, które mog¡ by¢
doª¡czane do plików ¹ródªowych nawet w innych programach.
Czytelnik powinien ju» umie¢ budowa¢ bardziej zªo»one typy danych, takie jak na
przykªad tablice struktur. Powinien spróbowa¢ samodzielnie napisa¢ program, w którym
zadeklaruje tablic¦ struktur oraz napisze operacje wczytywania i wy±wietlania warto±ci
struktur z tablicy. Mo»e nast¦pnie porówna¢ swój program z moim przykªadem.
#include <s t d i o . h>
2 #include <s t r i n g . h>
struct osoba {
4 char imi e [ 2 0 ] ;
int rok_urodzenia ;
6 } ;
int main ( ) {
8 struct osoba baza [ 1 0 ] ;
int i ;
10 for ( i = 0 ; i < 3 ; i++) {
p r i n t f ( " Imie : " ) ;
12 s c anf ( "%s " , baza [ i ] . imi e ) ;
p r i n t f ( "Rok urodz enia : " ) ;
14 s c anf ( "%d" , &baza [ i ] . rok_urodzenia ) ;
}
16 for ( i = 0 ; i < 3 ; i++)
p r i n t f ( " Imie : %s , rok urodz enia : %d\n" ,
18 baza [ i ] . imie , baza [ i ] . rok_urodzenia ) ;
return 0 ;
20 }
Jako ¢wiczenie przyjrzyjmy si¦ bli»ej temu fragmentowi &baza[i].rok_urodzenia. Jego
sens mo»emy wypowiedzie¢ tak: pobierz adres pola struktury, która znajduje si¦ na i-tym
indeksie w tablicy. Mamy tu trzy operatory unarne: pobierania adresu &, indeksowania
[] oraz dost¦pu do pola struktury .. Dwa ostatnie s¡ przyrostkowe wi¦c maj¡ najwy»szy
priorytet i b¦d¡ stosowane przed przedrostkowym &. Nast¦pnie musimy zastosowa¢ regu
ª¦ ª¡czno±ci bo mamy operatory o tym samym priorytecie. Przyrostkowe s¡ lewostronnie
ª¡czne, czyli wykonywane od lewej do prawej - jest to zgodne z naszym sposobem czytania
i rozumienia takich wyra»e« - uzyskaj dost¦p do elementu na i-tym indeksie (jest to struktura),
a nast¦pnie uzyskaj dost¦p do jej pola. Na koniec pobierz jego adres. Chcieliby±my
40
6. TABLICE I STRUKTURY
kolejny raz wskaza¢, »e reguªy priorytetów i ª¡czno±ci, cho¢ zªo»one, s¡ dopasowane do
sposobu w jaki najcz¦±ciej u»ywamy wyra»e« z wieloma operatorami.
Struktury mo»na równie» zagnie»d»a¢, to znaczy typem pola struktury mo»e by¢ inna
struktura. Czytelnik spróbuje wykona¢ nast¦puj¡ce ¢wiczenie.
.wiczenie 6.3 W programie z ostatnio omawianego przykªadu, zdeniowa¢ struktur¦
przechowuj¡c¡ informacje o adresie (miasto i kod pocztowy). Nast¦pnie wzbogaci¢ informacje
osobowe o adres, to znaczy zdeniowa¢ pole w strukturze osoba, którego typem
jest struktura adres. Zmodykowa¢ operacje odczytu i zapisu. Pamieta¢ o wªa±ciwym
u»yciu sªowa kluczowego struct.
41
Rozdziaª 7
Funkcje
W rozdziale tym poka»emy jak pisa¢ wªasne funkcje. Projektowanie i implementowanie
funkcji nale»y do podstawowych i najwa»niejszych czynno±ci programisty.
7.1 Intuicje
Prawie na ka»dym etapie pisania programu mo»na w nim wskaza¢ powtarzaj¡ce si¦ grupy
podobnych, czy nawet identycznych instrukcji lub fragmenty kodu, które maj¡ zbli»on¡
funkcjonalno±¢. Nale»y si¦ wówczas zastanowi¢ czy taka powtarzaj¡ca si¦ grupa kodu nie
powinna zosta¢ przeksztaªcona w funkcj¦. Organizacja kodu w funkcje ma wiele zalet,
pozwala na przykªad na ªatwe wprowadzanie zmian bo zmieniany kod wyst¦puje wówczas
w jednym miejscu - w ciele (inaczej: implementacji) funkcji. Dalej, raz napisane, dobrze
przetestowane funkcje mo»emy wykorzystywa¢ w wielu programach i organizowa¢ je w
biblioteki. Z funkcji korzystali±my ju» wielokrotnie, na przykªad z funkcji wy±wietlaj¡cej
na standardowym wyj±ciu ªa«cuchy znaków - printf czy wczytuj¡cej dane z klawiatury -
scanf. Inn¡ zalet¡ wyodr¦bniania kodu w postaci funkcji jest to, »e pozwalaj¡ podzieli¢
program na mniejsze, wyspecjalizowane cz¦±ci, dzi¦ki czemu ªatwiej jest dzieli¢ prac¦
po±ród wielu programistów oraz ªatwiej wyszukiwa¢ i naprawia¢ bª¦dy.
7.2 Prototyp
Pierwsz¡ czynno±ci¡ programisty pisz¡cego funkcj¦ powinno by¢ przemy±lenie jej prototypu.
Prototyp (inaczej deklaracja) okre±la jaki jest typ warto±ci zwracanej przez funkcj¦
oraz ile jest i jakie s¡ typy jej argumentów. Przedstawienie kompilatorowi funkcji w
postaci deklaracji przed jej u»yciem pozwala ju» na etapie kompilacji wykrywa¢ bª¦dy
polegaj¡ce na przykªad na przekazaniu do funkcji argumentów nieodpowiednich typów,
niewªa±ciwej ich liczby lub nieprawidªowego wykorzystania warto±ci zwracanej z funkcji.
7. FUNKCJE
Zapami¦taj! Kompilator jest najwa»niejszym narz¦dziem programisty. Niektórzy
twierdz¡ nawet, »e jest jego przyjacielem.
Zacznijmy od kilku przykªadów, poruszaj¡c przy okazji zagadnienia zwi¡zane z projektowaniem
prototypów.
Przykªad 7.1 Podaj prototyp funkcji obliczaj¡cej ±redni¡ arytmetyczn¡ trzech liczb caª-
kowitych.
double srednia3(int, int, int);
Powy»szy prototyp przedstawia kompilatorowi funkcj¦ o nazwie srednia3, która zwróci
wielko±¢ typu double oraz pobierze trzy argumenty typu int. Zwró¢my uwag¦, »e nazwy
parametrów funkcji w deklaracji s¡ opcjonalne. Nazwy parametrów w prototypie
nic kompilatorowi nie mówi¡ i nios¡ informacje jedynie dla programisty czytaj¡cego kod,
uªatwiaj¡c mu zrozumienie przeznaczenia funkcji. We wszystkich nieoczywistych przypadkach
powinni±my nazwy podawa¢.
Zapami¦taj! Sztuk¡ jest pisanie kodu, którego zrozumiej¡ inni. Czasy, w których
sztuk¡ byªo jedynie pisanie zrozumiaªego jedynie dla maszyny nale»¡ do odlegªej
przeszªo±ci.
Z tego samego powodu, nazwa funkcji te» powinna nie±¢ informacj¦ (cho¢by i skrótow¡)
o swoim przeznaczeniu. Zauwa»my, »e prototyp funkcji nie deniuje jej a jedynie j¡
przedstawia - deklaracja funkcji nie posiada wi¦c implementacji, ciaªa wyznaczonego przez
nawiasy {}, st¡d ±rednik na ko«cu prototypu.
Przykªad 7.2 Podaj prototyp funkcji wy±wietlaj¡cej na standardowym wyj±ciu tablic¦
liczb caªkowitych o okre±lonym rozmiarze.
void wyswietlTab(int tab[], int ilosc_elementow);
W tym miejscu poczynimy kilka wa»nych uwag. Ju» w momencie wyznaczania prototypu
funkcji programista podejmuje bardzo wa»n¡ decyzj¦, mianowicie w jakim stopniu
tworzona przez niego funkcja b¦dzie zale»na od kodu wywoªuj¡cego j¡ programu. W rozwa
»anym przykªadzie zapyta¢ mo»emy o to, sk¡d pochodzi¢ b¦dzie tablica, któr¡ funkcja
ma wy±wietli¢. Generalna zasada jest taka, »e funkcja powinna by¢ traktowana jak
swego rodzaju czarna skrzynka, której wszystkie potrzebne jej do dziaªania wielko±ci dostarczymy
w postaci argumentów a korzysta¢ b¦dziemy z warto±ci przez ni¡ zwracanej.
Korzysta¢ mo»emu równie» z mplementowanych przez ni¡ funkcjonalno±ci, zwanych czasami,
(wedªug mnie niefortunnie), efektami ubocznymi. Funkcje wywoªywane jedynie dla
ich efektów ubocznych nazywa si¦ czasami procedurami. Przykªadem funkcji, któr¡ wywo-
ªujemy dla jej warto±ci jest funkcja sqrt licz¡ca pierwiastek kwadratowy z zadanej liczby
43
7. FUNKCJE
a przykªadem funkcji, któr¡ wywoªujemy gªównie dla jej efektu ubocznego jest funkcja
printf.
W przypadku funkcji z omawianego przykªadu mo»liwy jest jeszcze taki prototyp:
void wyswietlTab(void);
Jednak»e funkcja tak zadeklarowana b¦dzie mogªa wy±wietla¢ jedynie konkretn¡ tablic¦,
której nazwa b¦dzie zaszyta (ang. hardcoded ) w implementacji. W poni»szym przykªadzie
b¦dzie to tablica o nazwie tab
void wyswietlTab(void) {
//...
for(i = 0;...) {
printf("Element na indeksie %d to: %d\n" , i, tab[i]);
}
}
Wykorzystanie takiej funkcji b¦dzie zatem bardzo ograniczone i zale»ne od kodu, który
j¡ wywoªuje. Generalnie programista powinien unika¢ pisania takich funkcji.
7.3 Tablice jako argumenty funkcji, problem rozmiaru
tablicy
Powró¢my do przykªadu 7.2. Istotny problem przy projektowaniu funkcji, którym przekazujemy
tablice w postaci argumentów, dotyczy ich rozmiaru. Funkcje operuj¡ce na
elementach tablic musz¡ wiedzie¢ ile elementów aktualnie si¦ w nich znajduje lub jaki
jest jej rozmiar (aby nie wykonywa¢ operacji poza zakresem tablicy). W j¦zyku C nie
istnieje sposób aby z samej tylko tablicy przekazanej jako argument funkcji, odczyta¢ ile
elementów ona przechowuje (wyj¡tkiem s¡ jedynie napisy traktowane jak tablice znakowe,
mówili±my o tym w podrozdziale 3.3). Prostym i zarazem uniwersalnym sposobem dostarczenia
tej informacji jest przekazywanie ilo±ci aktualnie przechowywanych elementów lub
rozmiaru w postaci kolejnego argumentu. W rzadkich przypadkach mo»na posªu»y¢ si¦
staª¡ globaln¡ zdeniowan¡ na przykªad za pomoc¡ #define, lecz nie jest to rozwi¡zanie
uniwersalne i polecane. Mo»na te» przechowywa¢ ilo±¢ elementów tablicy w zmiennej globalnej,
jest to przydatne w sytuacji, gdy inne funkcje mog¡ j¡ modykowa¢. Jednak je±li
nasza funkcja ma by¢ uniwersalna i operowa¢ na tablicach dowolnego rozmiaru konieczne
jest przekazanie ilo±ci elementów do wy±wietlenia w postaci parametru. Zapami¦tajmy
zatem reguª¦:
Zapami¦taj! Przy przekazywaniu tablicy jako argumentu do funkcji wskazane jest
przekazanie w postaci argumentu równie» jej rozmiaru czy aktualnej ilo±¢ elementów.
44
7. FUNKCJE
Uwaga, poni»szy kod cho¢ daje si¦ skompilowa¢ jest bª¦dny w tym sensie, »e nie przekazuje
do funkcji »adnej informacji o wielko±ci tablicy! Jest to cz¦sto spotykany bª¡d u
pocz¡tkuj¡cych programistów
Prototyp: void wyswietlTab(int tab[100]);
Wywoªanie: wyswietlTab(jakasTablica[100]);
Liczba 100 w powy»szym przykªadzie, w przypadku tablic jednowymiarowych, b¦dzie
caªkowicie pomini¦ta, zarówno w prototypie jak i w denicji funkcji a tak»e w kodzie
wywoªuj¡cym t¦ funkcj¦! Kompilator nie wygeneruje nawet ostrze»enia w przypadku
gdy podali±my w powy»szy sposób rozmiar 100 a przekazali±my tablic¦ rozmiaru 200. Nie
b¦dzie ostrze»enia równie» wtedy, gdy w deklaracji podali±my 100 a w denicji funkcji 300.
Informacja podana w ten sposób, w przypadku tablic jednowymiarowych, jest ignorowana
przez kompilator i nie powinni±my jej u»ywa¢. Prawidªowe rozwi¡zanie jest nast¦puj¡ce:
Prototyp: void wyswietlTab(int tab[], int rozmiar);
Wywoªanie: wyswietlTab(jakasTablica, 100);
Mamy kolejny przykªad:
Przykªad 7.3 Podaj prototyp funkcji, która dla dwóch tablic liczb caªkowitych znajdzie
najwi¦ksz¡ liczb¦ przechowywan¡ w tych tablicach.
int max2Tab(int tab1[], int rozmiar1, int tab2[], int rozmiar2);
lub
int max2Tab(int tab1[], int tab2[], int rozmiar1, int rozmiar2);
Zwró¢my tutaj uwag¦ na sformuªowanie zadania. Wyra»enia j¦zykowe w kontek±cie opisu
funkcji, zawieraj¡ce sformuªowania w stylu: funkcja dla (liczby, tablicy, struktury, . . . )
czy funkcja, której przekazujemy (liczb¦, tablic¦, struktur¦, . . . ) w zasadzie natychmiast
powinny skªania¢ programist¦ do umieszczenia tych wielko±ci na li±cie argumentów funkcji.
Podobnie, je±li funkcja znajduje, wyznacza, liczy jak¡± wielko±¢, typ tej wielko±ci powinien
znale¹¢ si¦ w deklaracji w miejcu warto±ci zwracanej.
7.4 Tablice dwuwymiarowe jako argumenty funkcji
Przekazywanie do funkcji tablic dwu i wi¦cej wymiarowych wymaga troch¦ dodatkowych
rozwa»a« w porównaniu z tablicami jednowymiarowymi. Zastanówmy si¦ w tym miejscu
w jaki sposób mo»e by¢ realizowana operacja indeksowania (czyli odczyt lub zapis
komórki) dla tablicy jedno i dwuwymiarowej. Wiemy ju», »e tablica jest tylko ci¡gªym
obszarem w pami¦ci. W przypadku tablicy jednowymiarowej dost¦p do i.. tego elementu
b¦dzie polegaª na wybraniu miejsca w pami¦ci, które jest oddalone od pocz¡tku tablicy
o tyle bajtów ile zajmuje jedna komórka (czyli rozmiar typu przechowywanych danych)
45
7. FUNKCJE
pomno»one przez indeks i »¡danego elementu. Czyli do wykonania operacji indeksowania
w tablicy jednowymiarowej nie jest potrzebna »adna dodatkowa informacja oprócz typu
(czyli rozmiaru) przechowywanej warto±ci. Informacj¦ t¦ funkcja odczytuje z deklaracji
swojego parametru b¦d¡cego tablic¡.
Jak wygl¡da indeksowanie w przypadku tablicy dwuwymiarowej? Przypu±¢my, pewna
funkcja otrzymuje w postaci argumentu tablic¦ dwuwymiarow¡ liczb typu int. Jej prototyp
mógªby wygl¡da¢ nast¦puj¡co:
void wyswietl(int tab[][], int ilosc_wierszy, int ilosc_kolumn);
Przyjmijmy dalej, »e w momencie wywoªywania tej funkcji, obszar pami¦ci zajmowany
przez t¦ tablic¦, tak j¡ widzi funkcja, to wyst¦puj¡ce po sobie kolejno 6 liczb:
1, 2, 3, 4, 5, 6. W ciele funkcji wyst¦puje operator indeksowania i »¡da dost¦pu do
elementu z drugiego wiersza i pierwszej kolumny: tab[1][0] (pami¦tamy, »e indeksy
liczymy od 0). Czy jest mo»liwe wyznaczenie tego elementu je±li znamy jedynie rozmiar
przechowywanych danych, tak jak w przypadku tablic jednowymiarowych? Czytelnik
spróbuje wykona¢ nast¦puj¡ce ¢wiczenie przyjmuj¡c, »e tablica dwuwymiarowa jest
interpretowana w ten sposób, »e najpierw znajduj¡ si¦ elementy z pierwszego wiersza,
bezpo±rednio za nim elementy z drugiego itd.
.wiczenie 7.1 Jaka b¦dzie szukana warto±¢ (tab[0][1]), je±li przyjmiemy, »e tablica
tab jest rozmiaru 2 na 3 a jaka, »e 3 na 2 (pami¦tamy, »e tablice te w pami¦ci wygl¡daj¡
identycznie).
Oczywi±cie warto±ci te b¦d¡ ró»ne. Jakiej wi¦c informacji brakuje, aby operator indeksowania
w tablicy dwuwymiarowej mógª dziaªa¢ poprawnie? Ilo±ci elementów w ka»dym
wierszu, czyli tyle, ile jest, uwaga, kolumn w tablicy. Dlatego te», kompilator zgªosi bª¡d o
niekompletnym typie w deklaracji funkcji z argumentem b¦d¡cym tablic¡ dwuwymiarow¡
je±li tablica ta nie b¦dzie miaªa podanej ilo±ci kolumn. Prawidªowa deklaracja funkcji z
omawianego przykªadu mo»e wygl¡da¢ na przykªad tak:
void wyswietl(int tab[][3], int ilosc_wierszy, int ilosc_kolumn);
a wywoªanie tak: wyswietl(tab, 2, 3);
Zauwa»my, »e czym innym jest podanie funkcji informacji o ksztaªcie tablicy (ilo±¢ kolumn)
w parametrze deniuj¡cym tablic¦ (int tab[][3]) a czym innym podanie, gªównie
ze wzgl¦dów bezpiecze«stwa, ilo±ci kolumn i wierszy (czyli sensownych warto±ci dla
operacji indeksowania). Problem przekazania informacji o rozmiarze dla tablic wielowymiarowych
pozostaje bez zmian.
Tablice o wi¦kszej ilo±ci wymiarów zachowuj¡ si¦ podobnie przy przekazywaniu ich
do funkcji - mo»emy zrezygnowa¢ z podawania jedynie pierwszej warto±ci okre±laj¡cych
ksztaªt tablicy.
46
7. FUNKCJE
7.5 Struktury jako argumenty funkcji
W przypadku przekazywania do funkcji struktur nie wolno zapomina¢ w jej deklaracji o
u»yciu sªowa kluczowego struct:
Przykªad 7.4 Podaj prototyp funkcji wy±wietlaj¡cej na standardowym wyj±ciu dane osoby,
przekazane do funkcji w postaci struktury osoba:
void wyswietlOsobe(struct osoba o);
Je±li funkcja nie zwraca »adnej warto±ci (tj. wywoªujemy j¡ dla jej efektów ubocznych),
powinni±my jawnie to zasygnalizowa¢ przy u»yciu sªowa kluczowego void w miejscu typu
zwracanej warto±¢. Je±li tego nie zrobimy, tj. zostawimy puste miejsce, kompilator przyjmie,
»e funkcja zwraca warto±¢ typu int . Mo»e to prowadzi¢ do braku reakcji ze strony
kompilatora na bª¦dy zwi¡zane z prób¡ u»ycia warto±ci zwracanej przez funkcj¦.
Przykªad 7.5 Podaj prototyp funkcji zwracaj¡cej bie»¡c¡ dat¦ w postaci struktury data.
struct data dzisiejsza_data(void);
Podobnie jak w poprzednim przykªadzie zwracamy uwag¦ na u»ycie sªowa struct w
miejscu deniowania typu zwracanej warto±ci, nie wolno o nim zapomina¢. Dalej, w
miejscu listy argumentów pojawia si¦ sªowo kluczowe void, które informuje kompilator,
»e funkcja nie pobiera »adnych parametrów. Je±li tego nie zrobimy i zostawimy puste
miejsce kompilator przyjmie, »e funkcja pobiera dowoln¡ liczb¦ argumentów. Podobnie
jak w przykªadzie poprzednim mo»e to prowadzi¢ do braku reakcji ze strony kompilatora
na pewne bª¦dy zwi¡zane z argumentami przekazanymi do funkcji. Zawsze wi¦c kiedy
funkcja nie pobiera »adnych argumentów powinni±my jawnie wskaza¢ to, w deklaracji, za
pomoc¡ sªowa kluczowego void.
7.6 Deniowanie funkcji
Gdy mamy ju» przemy±lan¡ pierwsz¡ wersj¦ prototypu (deklaracji) funkcji, mo»emy przyst
¡pi¢ do jej implementowania (deniowania). Gdy kod wywoªuj¡cy funkcj¦ zna jej prototyp
(tj. deklaracja pojawiªa si¦ w kodzie przed wywoªaniem), to jej denicja mo»e znale¹¢
si¦ w dowolnym pliku. Pami¦ta¢ musimy wówczas o doª¡czeniu skompilowanego pliku
w procesie linkowania. Szerzej o tym w rozdziale 9. Poni»ej przedstawimy przykªadowe
implementacje funkcji z poprzedniego podrozdziaªu o prototypach. Nie ma przepisu na
implementowanie funkcji - wi¦kszo±¢ mo»na zaimplementowa¢ na wiele sposobów, cz¦±¢
potrzebuje wªasnych algorytmów, czy sposobów rozwi¡zywania specycznych problemów.
Tego ucz¡ si¦ programi±ci w zasadzie przez caªe swoje zawodowe »ycie. Poni»ej bardzo
proste przykªady implementacji:
47
7. FUNKCJE
Przykªad 7.6 Funkcja licz¡ca ±redni¡ arytmetyczn¡ trzech liczb caªkowitych.
double srednia3(int a, int b, int c){
return (a + b + c)/3.0;
}
Ciaªo funkcji musi by¢ uj¦te w nawiasy klamrowe. Zwró¢my równie» uwag¦ na sªowo
kluczowe return, które ko«czy dziaªanie funkcji. Warto±¢ wyra»enia, które znajduje si¦
po sªowie return jest warto±ci¡ zwracan¡ z funkcji.
Przykªad 7.7 Funkcja wy±wietlaj¡ca na standardowym wyj±ciu tablic¦ liczb caªkowitych.
void wyswietlTab(int tab[], int ilosc_elementow) {
int i;
for(i = 0; i < ilosc_elementow, i++) {
printf("Element na indeksie %d to: %d\n" , i, tab[i]);
}
}
Zmienna i jest zmienn¡ lokaln¡ funkcji i jej widoczno±¢ rozci¡ga si¦ od miejsca denicji
do ko«ca bloku wyznaczaj¡cego ciaªo funkcji.
Przykªad 7.8 Funkcja zwracaj¡ca najwi¦ksz¡ z warto±ci z dwóch tablic liczb caªkowitych.
int max2Tab(int tab1[], int rozmiar1, int tab2[], int rozmiar2){
int max = tab1[0];
int i;
for(i = 1; i < rozmiar1; i++) {
if (tab1[i] > max ) max = tab1[i];
}
for(i = 0; i < rozmiar2; i++) {
if (tab2[i] > max ) max = tab[i];
}
return max;
}
Pytania jakie mo»e zada¢ sobie programista w momencie projektowania czy implementacji
funkcji mog¡ by¢ nast¦puj¡ce:
 czy funkcja korzysta ze zmiennych lub staªych globalnych ?
 czy funkcja korzysta ze staªych zdeniowanych w postaci dyrektywy #define?
 czy wykorzystuje inne funkcje z programu? czy wykorzystuje funkcje z innych,
zewn¦trznych bibliotek?
48
7. FUNKCJE
Im wi¦cej jest odpowiedzi tak na powy»sze pytania tym nasza funkcja jest bardziej zale
»na od kontekstu w którym ma zosta¢ u»yta. Kontekst dotyczy zarówno samego kodu
tworzonego programu jak i dost¦pno±ci w systemie operacyjnym wymaganych bibliotek.
Ogólnie, dobór listy argumentów dla tworzonych funkcji nie jest spraw¡ prost¡ i wymaga
od programisty pewnego do±wiadczenia. Nie zawsze bowiem sensowne jest d¡»enie do
du»ej niezale»no±ci kodu funkcji od kontekstu jej u»ycia.
7.7 Zmienne statyczne w funkcji
W rozdziale 3.1 i w powy»szych przykªadach u»ywali±my w funkcjach gªównie zmiennych
lokalnych, tj. takich, których czas »ycia ograniczaª si¦ do czasu wykonywania funkcji.
Ka»de kolejne wykonanie funkcji niszczyªo przechowywane warto±ci. Czasami jednak
chcieliby±my aby funkcja mogªa tworzy¢ i u»ywa¢ zmiennych, które b¦d¡ zachowywaªy
swoj¡ warto±¢ pomi¦dzy kolejnymi jej wywoªaniami. Jako przykªad mo»emy wskaza¢ potrzeb
¦ zliczania wywoªa« funkcji - gdy funkcja jest wywoªywana za pierwszym razem wykonywane
s¡ specyczne czynno±ci, gdy kolejny raz - jeszcze inne. Sªowo kluczowe static
przy deklaracji zmiennej lokalnej zapewnia wspomnian¡ funkcjonalno±¢. Zmienna taka,
zwana zmienn¡ statyczn¡, przechowuje kolejne warto±ci pomi¦dzy wywoªaniami funkcji.
Pami¦tajmy o zainicjalizowaniu takiej zmiennej ale nie dajmy si¦ zwie±¢ tej inicjalizacji -
b¦dzie ona wykonana tylko jeden raz podczas dziaªania programu!
#include <s t d i o . h>
2 void funkc j a ( void ){
s tat ic int l i c z n i k = 0 ;
4 i f ( l i c z n i k == 0 ) {
/ p i e rws z e wywolanie /
6 }
el se {
8 / k o l e j n e wywolania /
}
10 / Pamietamy o zwi e k s z aniu l i c z n i k a /
l i c z n i k++;
12 p r i n t f ( "Funkcja wywolana po raz %d\n" , l i c z n i k ) ;
return ;
14 }
16 int main ( ) {
funkc j a ( ) ;
18 funkc j a ( ) ;
funkc j a ( ) ;
49
7. FUNKCJE
20 return 0 ;
}
7.8 Przekazywanie agumentów do funkcji przez warto±¢
i przez adres
Wyja±nimy teraz pewien problem, który niezmiennie sprawia problem pocz¡tkuj¡cym
programistom. Problem polega na wskazaniu ró»nic przy przekazywaniu argumentu do
funkcji w postaci warto±ci zmiennej z przekazaniem jej adresu. Ró»nica w tych dwóch podej
±ciach ma bardzo wa»ne konsekwencje praktyczne. Gdy przy przekazywaniu u»ywana
jest warto±¢, to w funkcji, pod postaci¡ parametru uzyskujemy now¡ kopi¦ przekazanch
danych, nie zwi¡zan¡ ju» w »aden sposób z oryginaªem. Gdy natomiast u»ywamy adresów,
to przekazanie kopiuje sam adres danych i parametr funkcji staje si¦ wówczas now¡ nazw¡
dla tych samych danych! Gdy przekazujemy argumenty typu liczbowego, to sprawa jest
prosta - u»ywana jest warto±¢. Wjaki sposób jednak zachowuj¡ si¦ tablice i struktury przy
przekazywaniu ich do funkcji? Czy obszary pami¦ci, które im odpowiadaj¡ s¡ kopiowane,
czy te» kopiowane jest tylko wskazanie (adres) na ten obszar? Mamy tutaj wspaniaªe pole
do eksperymentu:
1. Konstruujemy tablic¦ (struktur¦) a
2. Tablic¦ (struktur¦) a wypeªniamy danymi.
3. Deniujemy funkcj¦, która pobiera argument typu tablica (struktura), nazwijmy go
b.
4. W denicji (ciele) ten funkcji modykujemy jako± tablic¦ (struktur¦) b.
5. Wywoªujemy funkcj¦ i przekazujemy jej tablic¦ (struktur¦) a
6. Porównujemy (cho¢by przez wy±wietlenie na ekranie) warto±ci tablic (pola struktur)
a przed wywoªaniem funkcji i po nim
7. Je±li s¡ ró»ne, to przekazali±my argument przez adres (modykacja w funkcji wpªyn
¦ªa na obiekt przekazany) a je±li równe, to przez warto±¢ (czyli modykacja w
funkcji nie wpªyn¦ªa na przekazany obiekt).
.wiczenie 7.2 Napisa¢ program realizuj¡cy opisane czynno±ci.
Gor¡ca pro±ba do czytelnika aby wykonaª to ¢wiczenie. Jestem pewien, »e bez problemu
poradzi sobie z tym zadaniem. Mam nadziej¦ równie», »e po jego wykonaniu doszedª do
podobnych wniosków:
50
7. FUNKCJE
Zapami¦taj! Tablice przy przekazywaniu do funkcji korzystaj¡ z adresu zmiennej i
parametr funkcji jest jedynie now¡ nazw¡ tych samych danych. Struktury natomiast
korzystaj¡ z warto±ci - tworz¡ now¡ kopi¦ danych.
Ró»nice w przekazywaniu tablic w stosunku do innych typów danych wynikaj¡ gªównie
ze wzgl¦dów praktycznych. Kopiowanie tablic, które mog¡ przecie» zawiera¢ du»e porcje
danych, ka»dorazowo przy wywoªywaniu funkcji byªoby operacj¡ czasochªonn¡.
Na tym mogliby±my zako«czy¢ rozwa»ania o przekazywaniu argumentów przez warto
±¢ i przez adres. Jednak dociekliwy czytelnik zasªuguje na dalsze wyja±nienia. Czy
aby na pewno istniej¡ dwa oddzielne mechanizmy przekazywania argumentów - jeden
dla tablic i drugi dla struktur i typów liczbowych? Oczywi±cie nie, sedno tkwi w tym
jak s¡ traktowane tablice przy przekazywaniu ich do funkcji. Do funkcji przekazywany
jest (ze wzgl¦dów wydajno±ciowych wspomnianych powy»ej) wska¹nik - adres pierwszego
elementu tablicy. Sam adres jest ju» przekazywany zwyczajnie czyli przez warto±¢. Mechanizm
przekazywania tablic pozwala zrozumie¢ dlaczego przy ich przekazywaniu zawsze
musimy podawa¢ te» rozmiar - funkcja otrzymuj¡c wska¹nik, nie jest w stanie odczyta¢ informacji
o rozmiarze tablicy. Umo»liwienie funkcjom modykacji obiektów spoza swojego
zakresu jest jedn¡ z przyczyn istnienia wska¹ników.
51
Rozdziaª 8
Wska¹niki czyli nie taki diabeª straszny
Poprzedni rozdziaª wskazaª nam korzy±¢ jak¡ daje w j¦zyku mo»liwo±¢ przekazywania
adresu zmiennej. W tym rozdziale przyjrzymy si¦ wska¹nikom czyli zmiennym, które
przechowuj¡ adresy innych zmiennych lub nawet dowolnych obszarów pami¦ci. Mam
wielk¡ nadziej¦, »e czytelnik dojdzie do wniosku, »e okropne opinie o wska¹nikach w C
s¡ mocno przesadzone a ich stosowane w podstawowym zakresie nie b¦dzie przysparza¢
»adnych kªopotów.
Zacznijmy od deklaracji zmiennych wska¹nikowych. Znak * informuje nas, »e mamy
do czynienia ze wskazaniem na dany typ:
int *pt;
double *x;
struct osoba *o;
Niektórzy pisz¡ gwiazdk¦ bezpo±rednio przy typie:
int* pt, a;
double* x, y;
nale»y jednak wyra¹nie zaznaczy¢, »e w takim zapisie zmienne a oraz y nie s¡ wska¹nikami
lecz zwykªymi zmiennymi. Sugeruj¦ na pocz¡tku nauki unika¢ tego typu notacji.
Zanim przejdziemy do przypisywania warto±ci wska¹nikom zacznijmy od ostrze»enia,
którego nieprzestrzeganie powoduje pojawianie si¦ komunikatów o naruszeniu ochrony
pami¦ci, zrzucaniu plików core, zawieszanie si¦ programów i innych podobnych a równie
denerwuj¡cych rzeczy.
Zapami¦taj! Ka»dy wska¹nik przed pierwszym u»yciem musi by¢ prawidªowo zainicjalizowany
- posiada¢ adres istniej¡cej zmiennej albo wskazywa¢ na przydzielony
obszar w pami¦ci.
I odwrotnie:
Zapami¦taj! Bardzo cz¦st¡ przyczyn¡ niespodziewanego przerwania dziaªania program
ów s¡ próby u»ycia niezainicjalizowanych wska¹ników.
Istniej¡ dwa sposoby nadawania warto±ci (w tym inicjalizowania) wska¹ników
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
1. Pobranie adresu zmiennej za pomoc¡ operatora przedrostkowego &.
2. Wskazanie na obszar w pami¦ci zwrócony z funkcji typu malloc (funkcje typu
malloc() b¦d¡ omówione w podrozdziale 8.2).
Oto przykªadowy sposób nadania warto±ci wska¹nikom:
int a;
int *x = &a;
struct osoba o;
struct osoba *wsk;
wsk = &o;
Przy deklaracjach jak wy»ej, dost¦p do tego samego obszaru w pami¦ci (przechowuj¡cego
warto±¢ zmiennej) mo»emy uzyska¢ na dwa sposoby: za pomoc¡ zmiennej oraz przy u»yciu
wska¹nika. Zmienna wska¹nikowa staje si¦ wi¦c aliasem dla pierwotnej zmiennej. Mo»e
to utrudnia¢ ±ledzenie warto±ci zmiennej i by¢ przyczyn¡ bª¦dów w programie.
W jaki sposób mo»emy odwoªa¢ si¦ (tj. przeczyta¢ lub zapisa¢) do warto±ci wskazanej
przez wska¹nik? W tej roli wyst¡pi poznana na wst¦pie tego rozdziaªu gwiazdka *. Mo»e
by¢ problemem dla pocz¡tkuj¡cych u»ywanie tego samego symbolu w dwóch ró»nych
kontekstach: przy deklaracji zmiennych wska¹nikowych oraz jako operator pobierania
(inaczej: wyªuskania) warto±ci ze wska¹nika. Niestety, u»ycie wska¹ników wymaga uwagi
i troszk¦ wprawy.
int a = 5;
int *ptr = &a;
*ptr = 7; - zmienna a ma teraz warto±¢ 7.
U»ycie wska¹ników do zmiennych liczbowych wyst¦puje stosunkowo rzadko. Cz¦sto
natomiast korzystamy ze wska¹ników do struktur - s¡ one przecie» wi¦kszymi porcjami
danych wi¦c u»ycie wska¹nika pozwala przekazywa¢ je do funkcji bez konieczno±ci ich
kopiowania (porównaj eksperyment z ko«ca rozdziaªu 7). Nast¦puj¡cy przykªad pokazuje
u»ycie wska¹ników do struktur:
1 #include <s t d i o . h>
struct osoba {
3 char imi e [ 2 0 ] ;
int rok_urodzenia ;
5 } ;
int main ( ) {
7 struct osoba o ;
struct osoba  opt r ;
9 opt r = &o ;
p r i n t f ( " Imie : " ) ;
11 s c anf ( "%s " , ( opt r ) . imi e ) ;
p r i n t f ( "Rok urodz enia : " ) ;
53
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
13 s c anf ( "%d" , &(( opt r ) . rok_urodzenia ) ) ;
p r i n t f ( "Osoba o imi eniu %s , urodzona w %d\n" ,
15 ( opt r ) . imie , ( opt r ) . rok_urodzenia ) ;
return 0 ;
17 }
Kilka wa»nych uwag odno±nie kodu programu z przykªadu. Po pierwsze zwracam uwag¦ na
istnienia zmiennej o - to na jej zawarto±¢ b¦dzie wskazywaªa zmienna wska¹nikowa optr.
Bez tego wska¹nik pozostanie niezainicjalizowany. Zatrzymajmy si¦ na linii 11. Nawiasy
s¡ konieczne gdy» chcemy dosta¢ si¦ do pola b¦d¡cego ªa«cuchem znaków poprzez wska¹-
nik na struktur¦ - operator . jako przyrostkowy ma wy»szy priorytet ni» przedrostkowy *.
Sprawa wygl¡da gorzej je±li chcemy pobra¢ adres pola struktury poprzez wska¹nik na ni¡
(linia 13). Tutaj te» nawiasy s¡ konieczne jednak kod zaczyna ju» wygl¡da¢ koszmarnie.
Gdyby±my tak mieli jaki± operator przyrostkowy (czyli o wysokim priorytecie), do wyªuskiwania
pól struktury z jej wska¹nika, to znakomicie uªatwiªoby to pisanie podobnych
instrukcji! Przedstawiam wi¦c czytelnikowi kolejny operator: ->. Skªada si¦ on z dwóch
znaków, bez spacji mi¦dzy nimi. Czytelnik napisze nowy program w którym zamieni lini¦
11. na nast¦puj¡c¡:
scanf("%s", optr->imie);
a koszmarn¡ lini¦ 13. na nast¦puj¡c¡:
scanf("%d", &(optr->rok_urodzenia)); Lini¦ 15. zmieni natomiast ju» bez »adnych
wskazówek z mojej strony.
8.1 Wska¹niki a tablice, arytmetyka wska¹nikowa, operator
sizeof
Eksperyment z ko«ca rozdziaªu 7 o funkcjach przekonaª czytelnika o tym, »e u»ywanie
adresów dla zmiennych, które przechowuj¡ wi¦ksze porcje danych, jest uzasadnione. Powy
»sze rozwa»ania o strukturach pokazuj¡ tak»e, »e efektywne u»ywanie wska¹ników do
struktur wymaga osobnego operatora. W przypadku tablic sprawa wygl¡da inaczej. Czytelnik
mo»e ju» domy±la¢ na czym rzecz polega - z rozwa»a« o ªa«cuchach znakowych w
funkcji scanf w rozdziale 2.4.
Zapami¦taj! Zmienna tablicowa mo»e by¢ w niektórych sytuacjach traktowana jak
wska¹nik - adres pierwszego elementu w tablicy!
Je±li tab jest tablic¡ liczb caªkowitych, to printf("%d ", *tab) wydrukuje jej pierwszy
element. .eby przyjrze¢ si¦ bli»ej tablicom jako wska¹nikom potrzebujemy jeszcze
umiej¦tno±ci przesuwania wska¹nika przez kolejne komórki pami¦ci. Jest to wst¦p do
arytmetyki wska¹ników. Z u»yciem wska¹ników zwi¡zane s¡ dwie operacje arytmetyczne:
54
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
 dodawanie do wska¹nika liczby caªkowitej
 odejmowanie dwóch wska¹ników
Przy obu tych operacjach musimy pami¦ta¢, »e ich znaczenie nie jest takie jak w arytmetyce
liczb caªkowitych. Otó» dodanie liczby caªkowitej do wska¹nika powoduje wskazanie
na obszar pami¦ci, który jest oddalony o tyle bajtów w pami¦ci, ile zajmuje wskazywany
typ danych pomno»one przez liczb¦ któr¡ dodajemy. Cho¢ formuªka mo»e wydawa¢ si¦
skomplikowana, to na przykªadzie tablic wida¢, »e jest prosta i naturalna - dodanie do
pocz¡tku tablicy liczby 1 wskazuje na nast¦pny, czyli drugi element w tablicy. Dzieje si¦
tak zawsze niezale»nie od typu (rozmiaru) przechowywanych w niej warto±ci. Dodanie
wi¦kszych liczb wskazuje na dalsze elementy. Zobaczmy przykªad:
1 #include <s t d i o . h>
int main ( ) {
3 int tab [ 5 ] = {2 , 4 , 6 , 8 , 1 0 } ;
int i ;
5 int wsk_tab ;
( tab + 3) = 1 7 ;
7 for ( i = 0 ; i < 5 ; i++) {
p r i n t f ( "%d " , ( tab+i ) ) ;
9 }
wsk_tab = tab ;
11 p r i n t f ( "\ nTabl ica raz j e s z c z e : \ n" ) ;
for ( i = 0 ; i < 5 ; i++){
13 p r i n t f ( "%d " , wsk_tab++);
}
15 return 0 ;
}
Linia 5. zmienia trzeci element tablicy (czyli ten na indeksie 4) na warto±¢ 17. Uwaga na
nawias w linii 7. - operator arytmetyczny ma ni»szy priorytet ni» unarne (tutaj wyªuskiwania)
wi¦c bez nawiasów wydrukowane zostan¡ kolejne liczby od 1 do 6. Jestem pewien,
»e czytelnik po chwili namysªu b¦dzie wiedziaª dlaczego.
Je±li chodzi o operacj¦ odejmowania dwóch wska¹ników, to jej rezultatem jest ilo±¢
elementów danego typu, które znajduj¡ si¦ pomi¦dzy tymi wska¹nikami. Nie b¦dziemy
przytaczali przykªadu, natomiast czytelnik powinien wykona¢ nast¦puj¡ce ¢wiczenie.
.wiczenie 8.1 Stworzy¢ tablic¦ 5 elementów typu int. Wy±wietli¢ liczby caªkowite b¦-
d¡ce rezultatem operacji odejmowania wska¹ników &tab[3]-&tab[0] i &tab[4]-&tab[2].
Sprawdzi¢, »e wynik operacji jest taki sam je±li zmienimy typ danych, które przechowuje
tablica.
55
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
Podkre±lmy w tym miejscu, »e zmienna tablicowa nie jest dokªadnie tym, czym jest wska¹-
nik. Nie mo»na na przykªad zmieni¢ warto±ci zmiennej tablicowej. Mo»na na niej wykonywa
¢ operacje arytmetyki wska¹nikowej ale samej zmiennej zmieni¢ ju» nie wolno. Mo»na
to zrobi¢ tylko dla zmiennych zadeklarowanych explicite jako wska¹niki.
.wiczenie 8.2 Zaobserwowa¢ komunikaty kompilatora przy próbie zmiany warto±ci zmiennej
tablicowej, na przykªad poprzez jej inkrementacj¦. Wskazówka: porówna¢ operacje z
linii 8. i 13. z ostatniego przykªadu.
Linia 13. z ostatniego przykªadu pokazuje, cz¦sto spotykan¡ w praktyce, operacj¦:
*wsk++;
Operacj¦ czytamy nast¦puj¡co: wyªuskaj warto±¢ ze wska¹nika a nast¦pnie zwi¦ksz go
o jeden. Nawiasy nie s¡ konieczne gdy» operator postinkrementacji jako przyrostkowy
ma wy»szy priorytet ni» przedrostkowe wyªuskanie. Zwró¢my te» uwag¦ na to, »e mamy
do czynienia z post-inkrementacj¡. Do operacji ªuskania pobrany wi¦c b¦dzie wska¹nik
przed zwi¦kszeniem.
Nast¦pny przykªad, bezwzgl¦dnie do zapami¦tania, u±wiadamia kolejn¡ ró»nic¦ mi¦dzy
tablicami a wska¹nikami - tablice alokuj¡ pami¦¢ potrzebn¡ do przechowywania swoich
elementów a wska¹niki nie!
#include <s t d i o . h>
2 #include <s t r i n g . h>
int main ( ) {
4 char imi e [ 2 0 ] ;
char  nazwisko ;
6 s t r cpy ( imie , "Han" ) ;
p r i n t f ( " Imie : %s \n" , imi e ) ;
8
/ Blad !
10 s t r c p y ( nazwisko , " Solo " ) ;
p r i n t f ("Nazwisko : %s \n" , nazwi sko ) ;
12 /
return 0 ;
14 }
Odkomentowanie linii 11. i 12. i uruchomienie programu na mojej maszynie powoduje
bª¡d czasu wykonania sygnalizowany komunikatem o naruszeniu ochrony pami¦ci.
Zanim zdradzimy jak alokowa¢ pami¦¢ dla zmiennych wska¹nikowych poznamy jeszcze
jeden bardzo wa»ny operator unarny - sizeof(). Operator ten przyjmuje jako argument
albo nazw¦ typu (zarówno pierwotnego int, double, char jak i zªo»onego, tablice czy
struktury) albo zmienne. Je±li u»ywamy nazw typów to musimy umie±ci¢ je w nawiasach
(najlepiej i tak w obu przypadkach u»ywa¢ nawiasów). Operator zwraca liczb¦ w bajtach
potrzebn¡ do alokacji zmiennej danego typu:
56
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
#include <s t d i o . h>
2 int main ( ) {
char imi e [ 2 0 ] ;
4 int l i c z b y [ 2 0 ] ;
struct osoba {
6 char imi e [ 2 0 ] ;
int rok_urodzenia ;
8 } ;
int  pt r ;
10 struct osoba  opt r ;
p r i n t f ( " Liczba c a lkowi t a %d\n" , s izeof ( int ) ) ;
12 p r i n t f ( "Tabl i ca l i c z b calkowi tych : %d\n" , s izeof ( l i c z b y ) ) ;
p r i n t f ( "Tabl i ca znakow : %d\n" , s izeof imi e ) ;
14 p r i n t f ( " St ruktura osoba : %d\n" , s izeof ( struct osoba ) ) ;
p r i n t f ( "Wskaznik na i n t : %d\n" , s izeof ( pt r ) ) ;
16 p r i n t f ( "Wskaznik na s t r u c t osoba : %d\n" , s izeof ( opt r ) ) ;
return 0 ;
18 }
8.2 Zarz¡dzanie pami¦ci¡
Gdy znamy ju» operator sizeof, to za jego pomoc¡ ªatwo mo»emy okre±li¢ ile bajtów
pami¦ci potrzebujemy. Teraz sama alokacja jest czynno±ci¡ prost¡: wystarczy u»y¢ funkcji
malloc() podaj¡c jej »¡dan¡ liczb¦ bajtów. Tak zainicjalizowanych wska¹ników mo»emy
ju» u»ywa¢ swobodnie:
#include <s t d i o . h>
2 #include <s t r i n g . h>
#include <s t d l i b . h>
4 struct osoba {
char imi e [ 2 0 ] ;
6 int rok_urodzenia ;
} ;
8 int main ( ) {
char nazwisko ;
10 struct osoba  opt r ;
nazwisko = ( char ) mal loc ( 5 0 ) ;
12 s t r cpy ( nazwisko , " Br z e c zys z c zyki ewi c z " ) ;
opt r = ( struct osoba ) mal loc ( s izeof ( struct osoba ) ) ;
57
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
14 s t r cpy ( optr..>imie , "Grzegorz " ) ;
optr..>rok_urodzenia = 1910;
16 p r i n t f ( " Imie : %s \n" , optr..>imi e ) ;
p r i n t f ( "Nazwisko : %s \n" , nazwisko ) ;
18 f r e e ( nazwisko ) ;
f r e e ( opt r ) ;
20 return 0 ;
}
Doª¡czyli±my systemowy plik nagªówkowy <stdlib.h>, który zawiera deklaracje funkcji
malloc() oraz free() . Ta ostatnia funkcja, jak zapewne domy±la si¦ czytelnik, sªu»y
do zwalniania zaalokowanej pami¦ci. Na wczesnym etapie nauki j¦zyka mo»na obowi¡zek
ten zrzuci¢ na system operacyjny, który po zako«czeniu programu automatycznie zwalnia
u»ywan¡ przez niego pami¦¢. Przyjrzyjmy si¦ teraz dokªadniej funkcji malloc. Liczb¦
bajtów które chcemy zaalokowa¢ mo»emy wskaza¢ bezpo±rednio lub, tak jak w zmiennej
nazwisko, wyliczy¢ za pomoc¡ sizeof. Funkcja malloc() zwraca wska¹nik na zaalokowany
obszar. Poniewa» jest funkcj¡ ogólnego przeznaczenia, to nie ma wiedzy o tym na
jaki typ jest to wska¹nik. Prototyp tej funkcji mówi, »e zwraca void *.. Wska¹nik na
void rozumiemy jako wska¹nik na obszar pami¦ci przechowuj¡cy dane dowolnego typu.
Powinni±my jednak w tym miejscu dokona¢ rzutowania na konkretny typ wska¹nika, który
potrzebujemy. Zwró¢my uwag¦ na jeszcze jeden aspekt: funkcja malloc zwraca staª¡ NULL
je±li nie ma wolnej dost¦pnej pami¦ci. W zasadzie wi¦c, wraz z malloc(), powinni±my
dodawa¢ wsz¦dzie kod podobny do tego:
if ((optr = malloc(sizeof(struct osoba))) == NULL) {
printf("Brak wolnej pamieci\n");
return 1;
}
8.3 Wska¹niki, tablice a argumenty funkcji
Z poprzedniego rozdziaªu dowiedzieli±my si¦, »e zmienne tablicowe mog¡ by¢ czasami
traktowane jak wska¹niki. W rozwa»aniach z ko«ca rozdziaªu 7 powiedzieli±my o mechanizmach
przekazywania zmiennych przez warto±¢ lub przez adres. Czytelnik domy±la si¦
zapewne w jaki sposób realizowane jest przekazywanie tablic jako argumentów funkcji?
Zapami¦taj! Przekazywanie tablic do funkcji realizowane jest przez przekazanie
wska¹nika reprezentowanego przez zmienn¡ tablicow¡. Dlatego w ciele funkcji nie
mo»na odczyta¢ rozmiaru przekazanej tablicy.
W rozdziale o funkcjach pisali±my prototypy funkcji pobieraj¡cych argumenty typu
tablica jednowymiarowa. Teraz mo»emy zapisa¢ je w równowa»ny, spotykany w praktyce,
58
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
sposób:
void wyswietlTab(int tab[], int ilosc_elementow);
jest równowa»ny
void wyswietlTab(int *tab, int ilosc_elementow);
Podobnie
int max2Tab(int tab1[], int rozmiar1, int tab2[], int rozmiar2)
jest równowa»ny
int max2Tab(int *tab1, int rozmiar1, int *tab2, int rozmiar2).
Kiedy jeszcze przydaje si¦ przekazanie do funkcji wska¹nika? Zawsze wtedy, gdy funkcja
ma zmieni¢ (wypeªni¢, ustawi¢) zmienne typów podstawowych i struktur. Takie wielko
±ci przekazywane s¡ zawsze przez warto±¢. Musimy tutaj u»y¢ wska¹ników. Zobaczmy
przykªad:
1 #include <s t d i o . h>
void maxmin( int tab , int rozmiar , int max , int min){
3 int i ;
max = tab [ 0 ] ; min = tab [ 0 ] ;
5 for ( i = 1 ; i < rozmiar ; i++) {
i f (  ( tab+i ) > max) max = ( tab+i ) ;
7 i f (  ( tab+i ) < min ) min = ( tab+i ) ;
}
9 }
int main ( ) {
11 int l i c z b y [ 2 0 ] = { ..10, 1 , 2 , 30 , 4 } ;
int najwi eks za ;
13 int najmni e j s za ;
maxmin( l i c zby , 5 , &najwi eks za , &najmni e j s za ) ;
15 p r i n t f ( "Max: %d , min : %d\n" , najwi eks za , najmni e j s za ) ;
return 0 ;
17 }
Czytelnik zwróci uwag¦ na nadawanie warto±ci zmiennym min, max wewn¡trz funkcji w
linii 4. Z prawej strony operatora przypisania mamy tab[0], cho¢ powiedzieli±my, »e
tablice w funkcjach s¡ wyª¡cznie wska¹nikami. Nie ma tutaj sprzeczno±ci - operator indeksowania
polega wªa±nie na operacji dodania liczby do wska¹nika: tab[i] jest tym
samym co *(tab+i). Jednak je±li zdecydujemy si¦ korzysta¢ z notacji wska¹nikowej, to
dla czytelno±ci kodu, powinni±my j¡ stosowa¢ konsekwentnie. W linii 14. mamy przykªad
wywoªania funkcji i przekazania tablicy oraz adresów zmiennych. Zwracamy uwag¦ na
konieczny operator pobrania adresu (&) przy zmiennych typów podstawowych (i strukturach),
dokªadnie tak samo jak robili±my to do tej pory w funkcji scanf(). Czytelnik
powinien bez problemu wykona¢ kolejne ¢wiczenie:
59
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
.wiczenie 8.3 Napisa¢ funkcj¦, która b¦dzie wypeªniaªa struktur¦ osoba (z poprzednich
przykªadów) danymi pochodz¡cymi od u»ytkownika. Funkcj¦ wywoªa¢ przekazuj¡c do niej
adres struktury. Po wywoªaniu wy±wietli¢ jej pola.
8.4 Dynamiczne zarz¡dzanie pami¦ci¡
Pora teraz na ¢wiczenia z bardziej zªo»onych struktur danych i wska¹ników. Przypu±¢my,
»e mamy za zadanie wczyta¢ z klawiatury, pewn¡ nieznan¡ liczb¦ nazwisk i przekaza¢
je do funkcji wyswietl(). Pierwsze podej±cie polega na próbie górnego oszacowania
ilo±ci nazwisk oraz ilo±ci znaków w ka»dym nazwisku i zdeniowaniu tablicy ªa«cuchów
znakowych:
char nazwiska[20][50];
Zdeniowali±my tablic¦ dwudziestu nazwisk co najwy»ej pi¦¢dziesi¦cio znakowych. W
tym miejscu kompilator przydzieli pami¦¢ do caªej tablicy, nawet wówczas, gdy oka»e si¦,
»e b¦dziemy przechowywa¢ mniejsz¡ liczb¦ nazwisk lub b¦d¡ one krótsze. W programie
pytamy u»ytkownika o ilo±¢ nazwisk i kolejno wypeªniamy tablic¦. Oczywi±cie je±li ilo±¢
nazwisk ma by¢ wi¦ksza od zadeklarowanej przez nas musimy zgªosi¢ bª¡d - w j¦zyku C nie
mo»na podczas dziaªania programu, zwi¦kszy¢ tablicy. Podobnie, je±li u»ytkownik poda
zbyt dªugie nazwisko, powinni±my je na przykªad obci¡¢ do zadeklarowanej dªugo±ci
(50) - funkcja strncpy().
.wiczenie 8.4 Napisa¢ program realizuj¡cy w funkcji main() wypeªnianie takiej tablicy.
Inne podej±cie, oszcz¦dzaj¡ce nieco pami¦¢ jest takie: zamiast przechowywa¢ w tablicy
peªne nazwiska, mo»emy przechowywa¢ w niej jedynie wska¹niki do nazwisk, a ka»de
nazwisko b¦dzie miaªo pami¦¢ przydzielan¡ wedle potrzeby (czyli dynamicznie) i by¢
mo»e posiadaªo inn¡ dªugo±¢. Oto deklaracja takiej tablicy:
char *nazwiska[20];
Dalszy sposób post¦powania mo»e by¢ nast¦puj¡cy. Deklarujemy sobie jedn¡ zmienn¡
pomocnicz¡ do chwilowego przechowywania wczytywanych nazwisk (bufor) jako tablic¦
znakow¡ o jakiej± zdroworozs¡dkowej (100?) ilo±ci znaków. Kolejne elementy tablicy
nazwiska staj¡ si¦ adresami obszarów przydzielonych dynamicznie za pomoc¡ funkcji
malloc() (przekazujemy do niej dªugo±¢ wczytanego nazwiska, strlen(bufor)).
.wiczenie 8.5 Napisa¢ program realizuj¡cy w funkcji main() wypeªnianie tablicy w podany
powy»ej sposób.
Nasz program wci¡» jednak posiada ograniczenie polegaj¡ce na konieczno±ci okre±lenia z
góry liczby nazwisk. Aby w peªni dynamicznie przydziela¢ pami¦¢ wedle potrzeb zarówno
je±li chodzi o ilo±¢ nazwisk jak i ich rozmiar deklaracja typu nazwiska b¦dzie nast¦puj¡ca:
char **nazwiska;
Poni»szy program realizuje to zadanie:
60
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
1 #include <s t d i o . h>
#include <s t r i n g . h>
3 #include <s t d l i b . h>
5 void wyswi e t l ( char ws zys tki e , int rozmiar ) ;
7 int main ( ) {
char  nazwiska ;
9 char bufor [ 3 0 0 ] ;
int i l o s c , i ;
11 p r i n t f ( " I l o s c nazwisk : " ) ;
s c anf ( "%d" , &i l o s c ) ;
13 nazwiska = ( char ) mal loc ( i l o s c  s izeof ( char  ) ) ;
for ( i = 0 ; i < i l o s c ; i++) {
15 p r i n t f ( "Nazwisko %d : " , i + 1 ) ;
s c anf ( "%s " , bufor ) ;
17 ( nazwiska + i )= ( char ) mal loc ( s t r l e n ( bufor ) + 1 ) ;
s t r cpy (  ( nazwiska + i ) , bufor ) ;
19 }
wyswi e t l ( nazwiska , i l o s c ) ;
21 return 0 ;
}
23
void wyswi e t l ( char ws zys tki e , int rozmiar ) {
25 int i ;
p r i n t f ( "\ nWszystkie nazwiska : \ n" ) ;
27 for ( i = 0 ; i < rozmiar ; i++) {
p r i n t f ( "Nazwisko %d : %s \n" , i + 1 , ( ws zys tki e+i ) ) ;
29 }
}
Typ char **nazwiska; mo»emy wyobra»a¢ sobie lub kojarzy¢ wªa±nie jako tablic¦ dwuwymiarow
¡. Dokªadnie w taki sposób jak pokazywali±my kolejne wersje tablicy nazwiska.
Wnaszym przykªadzie, zwró¢my uwag¦ na denicj¦ funkcji wyswietl(). Zamiast operatora
indeksowania u»ywamy wyra»enia *(nazwiska + i) omówionego w szczegóªach
w podrozdziale 8.3.
Powy»szy przykªad mo»e wyda¢ si¦ czytelnikowi troch¦ trudny - prezentuje on jednak
wa»n¡ zalet¦ j¦zyka C: elastyczno±¢ w zarz¡dzaniu pami¦ci¡. Wymaga za to uwa»nego
programowania cho¢by ze wzgl¦du na zawiªo±ci skªadni arytmetyki wska¹nikowej. Gdy
czytelnik nabierze ju» wprawy, tego typu zadania stan¡ si¦ dla niego prostsze.
61
8. WSKA.NIKI CZYLI NIE TAKI DIABE. STRASZNY
8.5 const oraz wska¹niki
Na koniec przyjrzymy si¦ jeszcze sªowu kluczowemu const w kontek±cie wska¹ników.
const u»yte w deklaracji argumentu funkcji zabezpiecza argument przed jego zmian¡
(dba o to kompilator) - dziaªanie funkcji nie mo»e zmieni¢ warto±ci argumentu. Jednocze
±nie explicite wskazuje intencje programistyczne - oto argument tylko do odczytu. W
przypadku argumentów, które s¡ wska¹nikami ma to szczególne wa»ne znaczenie - o ile
zmiana warto±ci parametru funkcji, który przechowuje adres nie jest na ogóª szkodliwa (w
funkcji mamy tylko jego kopi¦), o tyle bardzo przydatne jest zabezpieczenie przed zmian¡
warto±ci na któr¡ wska¹nik wskazuje. Oto jak zadeklarowana jest, wykorzystywana
przez nas wielokrotnie, funkcja strcpy():
char *strcpy(char *dest, const char *src);
Pierwszy argument to ªa«cuch na który kopiujemy a drugi to ¹ródªo. Operacja kopiowania
ze swej natury nie powinna w »aden sposób zmienia¢ ¹ródªa. Dlatego dodanie sªowa
kluczowego const zabezpiecza (i informuje u»ytkowników), »e warto±¢ wskazywana przez
src nie zostanie w niej zmieniona. Czytelnik wykona nast¦puj¡cy eksperyment:
.wiczenie 8.6 Napisa¢ funkcj¦ kopiuj¡c¡ tablic¦ liczb caªkowitych (podobnie jak w funkcji
strcpy). Doda¢ sªowo const przy deklaracji argumentu b¦d¡cego tablic¡ ¹ródªow¡.
Spróbowa¢ zmieni¢ tablic¦ ¹ródªow¡ w ciele funkcji i zaobserwowa¢ komunikat kompilatora.
62
Rozdziaª 9
Budowanie aplikacji
Do tej pory pisali±my proste programy, których kod mie±ciª si¦ w jednym pliku ¹ródªowym.
Jednak ka»da wi¦ksza aplikacja osi¡ga tak¡ ilo±¢ kodu, »e trzymanie wszystkich jej funkcji
w jednym pliku staje si¦ niewygodne. Je±li dodamy do tego prac¦ w zespole, to takie
podej±cie praktycznie j¡ parali»uje. Zach¦cam czytelnika aby dla wªasnej wygody dzieliª
swoje, by¢ mo»e wci¡» niewielkie, programy na mniejsze cz¦±ci. O tym jak dzieli¢ program
na mniejsze jednostki a pó¹niej budowa¢ caª¡ aplikacj¦, traktuje niniejszy rozdziaª.
9.1 Pliki z funkcjami
Najprostszym sposobem zycznego podziaªu kodu jest zwykªe wyodr¦bnienie plików,
które b¦d¡ zawieraªy kod ¹ródªowy funkcji, pogrupowanych wzgl¦dem implementowanych
funkcjonalno±ci. Przypu±¢my, »e mamy wyodr¦bnione dwa pliki z funkcjami: menu.c i
pomocnicze.c oraz jeden zawieraj¡cy funkcj¦ main(): glowny.c. Zaªó»my dalej, »e
funkcje s¡ implementowane przez ró»nych programistów i ka»dy z nich ma obowi¡zek
skompilowa¢ swój kod niezale»nie od kodu pozostaªych. Dla upewnienia czytelnika, »e
kompilacja b¦dzie odbywaªa si¦ niezale»nie od innych plików z funkcjami, przed kolejnymi
czynno±ciami przenie±my wspomniana pliki ¹ródªowe do oddzielnych katalogów. Do
kompilacji (bez procesu konsolidacji) u»ywamy programu gcc z przeª¡cznikiem -c (zapami
¦taj: -c jak compile):
gcc -c pomocnicze.c
gcc -c menu.c
Wynikiem powy»szych kompilacji s¡ pliki obiektowemenu.o oraz pomocnicze.o, zwane
te» plikami relokowalnymi (pliki obiektowe nie maj¡ nic wspólnego z poj¦ciami z zakresu
programowania obiektowego). S¡ one efektem kompilacji i przeznaczone do dalszego przetwarzania
przez konsolidator (inaczej linker ). Wa»ne aby czytelnik rozumiaª, »e do samej
kompilacji funkcji, bez procesu konsolidowania, nie s¡ potrzebne inne pliki obiektowe.
Dzieje si¦ tak nawet je±li funkcje, które wªa±nie kompilujemy korzystaj¡ z funkcji z innych
plików obiektowych. Upraszczaj¡c, dzieje si¦ tak dlatego, »e powi¡zanie wywoªa« funkcji
9. BUDOWANIE APLIKACJI
z ich ciaªami odbywa si¦ dopiero w procesie linkowania a nie kompilacji.
Wykonajmy teraz kilka eksperymentów na plikach ¹ródªowych naszego hipotetycznego
programu wy±wietlaj¡cego menu na ekranie i wykonuj¡cego jakie± obliczenia zgodnie z pozycj
¡ wybran¡ z menu. B¦d¡ nas interesowaªy jedynie aspekty zwi¡zane z budowaniem (tj.
kompilacj¡ i linkowaniem) aplikacji oraz zwi¡zkami mi¦dzy funkcjami i zmiennymi jakie
wyst¦puj¡ w kodzie, nie za± sama implementacja aplikacji. Nazwy u»ytych funkcji b¦d¡
wskazywaªy ich przeznaczenie. Plik menu.c zawiera funkcje zwi¡zane z wy±wietlaniem
menu na ekranie:
void wyswietl_menu ( void ){
2 rysuj_okno ( ) ;
/ Tutaj d a l s z y kod wy swi e t l a j a c y menu /
4 }
void wykonaj_pozycje ( void ){
6 int pozyc ja = pobierz_pozycje_menu ( ) ;
wykonaj ( pozyc ja ) ;
8 / Dal s zy kod /
}
10 / Po z o s t a l e f unk c j e /
W menu.c wykorzystywane s¡ funkcje zdeniowane w pliku pomocnicze.c:
#include "okna . h"
2
int domyslna_szerokosc = 8 0 ;
4
void rysuj_okno ( void ){
6 / Tutaj kod r y suj a c y okno /
}
8 int pobierz_pozycje_menu ( void ){
/ Tutaj kod p o b i e r a j a c y od
10 uzytkownika p o z y c j e z menu /
}
12 void wykonaj ( int pozyc ja ){
/ Kod o b s l u g u j a c y p o z y c j e z menu /
14 }
void czysc_ekran ( void ){
16 / Kody o b s l u g u j a c y c z y s z c z e n i e ekranu /
}
18 / Po z o s t a l e f unk c j e /
64
9. BUDOWANIE APLIKACJI
Funkcja main() znajduje si¦ natomiast w pliku glowny.c i korzysta z funkcji z pliku
menu.c oraz by¢ mo»e innych z pomocnicze.c:
int g l oba lna = 7 ;
2 int main ( ) {
while ( 1 ) {
4 wyswietl_menu ( ) ;
wykonaj_pozycje ( ) ;
6 / Dal s zy kod /
czysc_ekran ( ) ;
8 }
return 0 ;
10 }
Spróbujmy skompilowa¢ plik menu.c (niech on równie» znajduje si¦ on w osobmym katalogu):
gcc -c menu.c
Kompilacja powiodªa si¦! Sk¡d jednak kompilator wie czy prawidªowo wywoªujemy funkcj
¦ rysuj_okno(), skoro pochodzi ona z innego pliku? Kompilator przyjmuje bowiem
pewne ogólne zaªo»enia o funkcjach, których nie zna. Przyjmuje, »e zwracaj¡ warto±¢
typu int oraz pobieraj¡ dowoln¡ liczb¦ argumentów. Zdecydowanie powinni±my unika¢
takich sytuacji - kompilator wspiera prac¦ programisty i mo»liwie szybko powinni±my
umo»liwic mu wskazywanie sytuacji potencjalnie niebezpiecznych, takich jak powy»sza.
Sªu»y do tego opcja -Wall , której powinni±my u»ywa¢ jak najcz¦±ciej (zapami¦tajmy:
Wall jak warnings all, wszystkie ostrze»enia):
gcc -c -Wall menu.c
Teraz dostajemy m.in. ostrze»enie o tym, »e kompilator przyj¡ª pewne zaªo»enia o funkcji
rysuj_okno:
menu.c:2:2: warning: implicit declaration of function `rysuj_okno'
Z rozdziaªu 7 wiemy, »e brakuje deklaracji (prototypu) tej funkcji. Po dodaniu brakuj¡-
cych deklaracji wszystkich funkcji, z których korzystamy, ostrze»enia znikaj¡. Podobnie
czynimy z pozostaªymi plikami, w tym równie» z plikiem glowny.c.
Zapami¦taj! Je±li programista zna prototypy funkcji z których korzysta, to do prawid
ªowej kompilacji nie potrzebuje plików obiektowych lub bibliotek, zawieraj¡cych
ich denicje.
Jak zatem stworzy¢ jeden program wykonywalny i dokona¢ linkowania? Najpro±ciej
u»ywaj¡c programu gcc, któremu podajemy pliki obiektowe. Musimy je jeszcze skopiowa¢
do jednego katalogu. Dodajmy jeszcze pomocniczo opcje -Wall oraz -o:
gcc -Wall glowny.o menu.o pomocnicze.o -o aplikacja
65
9. BUDOWANIE APLIKACJI
9.2 Pliki nagªówkowe
Czytelnik zapewne zwróciª uwag¦ na »mudn¡ i cz¦sto powtarzan¡ czynno±¢: deklarowanie
funkcji w ka»dym pliku, w którym z nich korzystamy. Aby czynno±¢ t¦ usprawni¢
stworzymy wªasne pliki nagªówkowe, w których znajd¡ si¦ deklaracje tych funkcji, które
skªadaj¡ si¦ na wytwarzany przez nas moduª. W praktyce pliki nagªówkowe tworzymy
zarówno dla caªych bibliotek, które przedstawiaj¡ swoje funkcje i typy danych ich u»ytkownikom,
jak i nawet dla pojedynczych plików z funkcjami pomocniczymi. W naszym
przykªadzie stworzymy dwa pliki nagªówkowe zawieraj¡ce deklaracje odpowiednich funkcji:
"menu.h" oraz "pomocnicze.h". Teraz wystarczy doª¡czy¢, wedle potrzeby, za pomoc
¡ dyrektywy #define, odpowiednie pliki nagªówkowe, które oczywi±cie programista -
twórca funkcji musi udost¦pni¢. W pliku menu.c, który korzysta z pomocnicze.h dodajemy
na pocz¡tku lini¦:
#include "pomocnicze.h"
a w pliku glowny.c, który korzysta z funkcji z obydwu plików:
#include "pomocnicze.h"
#include "menu.h"
Zauwa»my, »e nazw¦ pliku do doª¡czenia, który nie znajduje si¦ w pewnych ustalonych
miejscach - katalogach systemowych, podajemy przy u»yciu " ". Taki plik najcz¦±ciej
umieszczamy w katalogu bie»¡cym.
Co jeszcze mo»emy dla wygody umieszcza¢ w plikach nagªówkowych? Przypu±¢my,
»e we wszystkich plikach z funkcjami z naszego programu wykorzystujemy ten sam typ
danych, pewn¡ struktur¦ opisuj¡c¡ wirtualne okno:
struct okno {
int wysokosc;
int szerokosc;
int kolor_tla;
/* Dalsze deklaracje pol */
};
Zamiast dodawa¢ tak¡ denicj¦ w ka»dym pliku z funkcjami, lepiej umie±ci¢ j¡ w oddzielnym
pliku nagªówkowym, na przykªad "okna.h" i doª¡cza¢ ten plik w innych plikach
nagªówkowych.
Pojawi si¦ tutaj jednak pewien problem zwi¡zany z sytuacj¡, która wyst¡pi w momencie
doª¡czenia dwóch (lub wi¦cej) plików nagªówkowych, które same doª¡czaj¡ "okna.h"
i tym samym deniuj¡ dwukrotnie ten sam typ danych. Kompilator nie pozwoli na rede-
nicj¦ typu - cho¢by denicje byªy identyczne.
Zapami¦taj! Wi¦kszo±¢ j¦zyków programowania, w tym równie» C, nie dopuszcza
wi¦cej ni» jednej denicji typu o tej samej nazwie. Wielokrotna deklaracja nie jest
natomiast bª¦dem.
66
9. BUDOWANIE APLIKACJI
Jak wi¦c nale»y radzi¢ sobie w opisanej powy»ej sytuacji? Skorzystamy tutaj z techniki
zwanej #include guard. Otó» przy denicji typu zapytamy czy byªa on ju» wcze±niej
zdeniowany i je±li nie, to podamy denicj¦. Efekt ten uzyskujemy za pomoc¡ sztuczki z
dyrektyw¡ #definie i #ifndef umieszczonych na pocz¡tku pliku "okna.h":
#i fndef OKNA_H
2 #define OKNA_H
4 struct okno {
int wysokosc ;
6 int s z e r o k o s c ;
int ko l o r_t l a ;
8 / Dal s z e d e k l a r a c j e p o l /
} ;
10 / Kolejne wspolne d e f i n i c j e /
#endif
W pozostaªych plikach dodajemy #include "okna.h". Plik "menu.h":
1 #include "okna . h"
void wyswietl_menu ( void ) ;
3 void wykonaj_pozycje ( void ) ;
/ De k l ar a c j e p o z o s t a l y c h f u n k c j i /
Plik "pomocnicze.h":
#include "okna . h"
2 void rysuj_okno ( void ) ;
int pobierz_pozycje_menu ( void ) ;
4 void wykonaj ( int pozyc ja ) ;
void czysc_ekran ( void ) ;
6 / De k l ar a c j e p o z o s t a l y c h f u n k c j i /
Teraz kompilacja pliku glowny.c, który doª¡cza oba powy»sze pliki nie spowoduje bª¦dów.
9.3 Wspóªdzielenie zmiennych, sªowa kluczowe extern i
static
W rozdziale 3.1 powiedzieli±my, »e zmienne globalne s¡ dost¦pne w caªym programie. W
poprzednim podrozdziale podzielili±my program na wiele plików. Jak zatem sprawi¢, by
zmienne globalne byªy widziane w innych plikach oraz przeciwnie, jak si¦ zabezpieczy¢
aby niektóre zmienne byªy widoczne tylko w swoim pliku ¹ródªowym? Przypomnijmy, »e
67
9. BUDOWANIE APLIKACJI
sprawa dotyczy jedynie zmiennych globalnych, czyli takich, które s¡ zadeklarowana poza
ciaªami wszelkich funkcji. Rozwa»my zmienn¡ globalna z pliku glowny.c. Jak nale»y
tak¡ zmienn¡ zadeklarowa¢ w pliku menu.c aby wskaza¢, »e mamy na my±li zmienn¡,
która jest zdeniowana (czyli utworzona) gdzie indziej? Do tego wªa±nie sªu»y sªowo
kluczowe extern. Przedstawia jedynie zmienn¡ funkcjom w pliku ale nie pozwala jej
tworzy¢. Mówi kompilatorowi, »e ta zmienna zostanie dostarczona w momencie konsolidowania
caªego programu. Je±li chcemy w pliku menu.c u»ywa¢ zmiennej globalna
zdeniowanej poza tym plikiem dodajemy sªowo extern do jej deklaracji:
extern int globalna;
Brak sªowa extern w takich sytuacjach mo»e skutkowa¢ niecelowym przykrywaniem
zmiennych pochodz¡cych z wielu plików i posiadaj¡cych t¦ sam¡ nazw¦.
Jak wi¦c nale»y post¡pi¢ je±li chcemy zaznaczy¢, »e zmienna, któr¡ wykorzystujemy
w wielu funkcjach z jednego pliku jest zmienn¡ globaln¡, która jest przeznaczon¡ jedynie
dla tego pliku ¹ródªowego? Innymi sªowy nie chcemy aby zmienna ta, przypadkowo
lub celowo, zostaªa u»yta poza plikiem. U»ywamy do tego sªowa kluczowego static. .
Zmienna taka staje si¦ dost¦pna jedynie wewn¡trz pliku ¹ródªowego, w którym zostaªa
zdeniowana. Je±li tak¡ zmienn¡ ma byc domyslna_szerokosc z pliku pomocnicze.c, to
jej prawidªowa denicja powinna wygl¡da¢ tak:
static int domyslna_szerokosc;
Gor¡co zach¦cam czytelnika, aby u»ywaª mo»liwie cz¦sto sªów extern oraz static i jawnie
wskazywaª na zmienne globalne caªego programu i lokalne pliku. Sprawom widzialno±ci
zmiennych w ró»nych zakresach w programie po±wi¦cono bardzo wiele uwagi w nowszych
j¦zykach programowania. Mam nadziej¦, »e poni»sze eksperymenty nie b¦d¡ stanowiªy
dla czytelnika trudno±ci i pomog¡ utrwali¢ znaczenie poznanych sªów kluczowych.
.wiczenie 9.1 Sprawdzi¢ co si¦ stanie, gdy zapomnimy w programie zdeniowa¢ zmiennej
globalnej, to znaczy we wszystkich plikach u»yjemy deklaracji ze sªowem extern? Czy
bª¡d pojawi si¦ ju» podczas kompilacji czy dopiero linkowania programu?
68
Rozdziaª 10
Naprawd¦ krótkie zako«czenie
W tym miejscu chciaªbym si¦ czytelnikowi w paru sªowach przedstawi¢ i skierowa¢ do
niego pewn¡ pro±b¦. Nale»¦ do wielkich miªo±ników programowania. Przygod¦ z programowaniem
zaczynaªem od j¦zyka Pascal, który dostarczyª mi podstawowych intuicji
programistycznych - jemu zawdzi¦czam podstawow¡ wiedz¦ czym jest p¦tla w programie
i jak budowa¢ funkcje. Pó¹niej byª j¦zyk C i te okropne wska¹niki. Dzi¦ki C i wska¹nikom
mogªem eksperymentowa¢ z funkcjami systemowymi i programowaniem sieciowym w
systemie operacyjnym Linux. Dalej przyszedª czas na j¦zyki obiektowe. Tutaj zaliczyªem
swoje pierwsze programistyczne rozczarowanie - z wykªadu na uczelni nie wyniosªem wiele.
Pomy±laªem wtedy, »e programowanie obiektowe nie jest dla mnie. Wówczas traªem na
genialn¡ ksi¡»k¦ - Thinking in Java. Jej autor, Bruce Eckel, staª si¦ dla mnie wzorem je-
±li chodzi o nauczanie programowania. W ksi¡»ce tej zadawaª pytania i prostym j¦zykiem,
przy pomocy ciekawych przykªadów, odpowiadaª na nie. Nauczaª programowania cz¦sto
zadaj¡c pytanie dlaczego jest tak a nie inaczej"? Dzi± Java jest tym j¦zykiem, który
poznaªem najlepiej i najbardziej polubiªem. Od tamtego czasu poznaªem jeszcze kilka innych
j¦zyków a ostatnio przygl¡dam si¦ z wielkim zainteresowaniem j¦zykowi Scala, który
zapewne niedªugo stanie si¦ moim ulubionym :). Do czego zmierzam? Je±li czytelnik odkryje
w sobie rado±¢ z programowania, kolejnych j¦zyków b¦dzie uczyª si¦ szybko a wielki
±wiat b¦dzie staª dla niego otworem. Równie» w dosªownym sensie - programi±ci, którzy
rozwin¦li w sobie umiej¦tno±¢ sprawnego programowania oraz poznawania j¦zyków, s¡ i
b¦d¡ nieustannie poszukiwani na mi¦dzynarodowym rynku pracy.
Kolejny wielki i ciekawy ±wiat, to technologie towarzysz¡ce wytwarzaniu oprogramowania
oraz frameworki uªatwiaj¡ce wytwarzanie zªo»onych aplikacji. Tym wªa±nie zajmuj¦
si¦ na codzie« - technologiami Java Enterprise Edition oraz frameworkami takimi jak
Spring czy Hibernate. Nie wiem czy daªbym rad¦ pozna¢ te ±wiaty gdyby nie podstawy,
które daª mi j¦zyk C. Dlatego, po raz kolejny to podkre±l¦, mam nadziej¦, »e pomog¦ czytelnikowi
w zrobieniu pierwszych kroków oraz zach¦c¦ do nauki równie» innych j¦zyków
programowania.
Teraz pora na moj¡ pro±b¦. Ka»dy, nawet zrobiony z najwi¦ksz¡ staranno±ci¡ nowy
10. NAPRAWD. KRÓTKIE ZAKO.CZENIE
materiaª dydaktyczny zawiera luki, bª¦dy (zarówno literówki jak i merytoryczne), nie-
±cisªo±ci lub niedopowiedzenia. Je±li czytelnik znajdzie takowe lub b¦dzie miaª innego
rodzaju uwagi czy sugestie, to bardzo prosz¦ o maila na adres skryptC@gmail.com. B¦d¦
bardzo wdzi¦czny.
70
Indeks
n0, 18
-Wall, 65
-c, 63
-o, 7
<string.h>, 17
a.out, 7
break, 33
case, 29
char, 15
const, 62
continue, 33
do while, 33
double, 10
dyrektywa dene, 9
dyrektywa ifndef, 67
dyrektywa include, 8
extern, 67
oat, 10
for, 32
free, 58
funkcja, 42
funkcja denicja, 47
funkcja deklaracja, 42
funkcja prototyp, 42
if, 28
int, 14
komentarze w kodzie, 14
kompilator, 6
konsolidacja, 63
linkowanie, 63
long, 14
main(), 8
malloc, 57
null character, 18
pliki nagªówkowe *.h, 66
preprocesor, 8
printf, 10
scanf, 11
short, 14
sizeof, 56
standard ANSI C, 4
standard ISO C, 4
static w funkcjach, 49
static w pliku, 67, 68
strcat(), 17
strcmp(), 18
strlen(), 17
struct, 38
struktura, 38
switch, 29
tablica jako argument funkcji, 44
void, 47, 58
while, 31
zmienne globalne, 13
zmienne lokalne, 13
zmienne, zakresy, 15